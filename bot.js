//–≠—Ç–æ –∫–æ–º–µ–Ω—Ç–∞—Ä–∏–π
// console.warn = () => {}
// console.error = () => {}
// //–Ω–µ –∑–∞—Å–æ—Ä—è—è –∫–æ–Ω—Å–æ–ª—å

require('dotenv').config()
const mineflayer = require('mineflayer');
const { pathfinder, Movements, goals } = require('mineflayer-pathfinder');
const { GoalNear, GoalFollow, GoalBlock } = goals;
const collectBlock = require('mineflayer-collectblock').plugin;
const toolPlugin = require('mineflayer-tool').plugin;
const { plugin: pvp } = require('mineflayer-pvp');
const armorManager = require('mineflayer-armor-manager');
const plasmo = require("mineflayer-plasmovoice")
const vec3 = require('vec3');
const movement = require("mineflayer-movement")
const ffmpeg = require('fluent-ffmpeg');
const fs = require('fs');
const path = require('path');
const readline = require('readline');
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
    prompt: '> '
});

const WATCHED_PLAYERS = ['vlkardakov', 'Rusvanplay', 'console', 'Molni__'];// 'monoplan',
const RICH_ITEMS = ["diamond", "gold", "emerald", "netherite", "enchant", "elytr", "_block", "fire", "sword", "totem", "bow", "golden_", "mace", "ore"];
const RANGE_GOAL = 0;
let protectedPlayer = null;
let following = false;
let miningSand = false;
let followingProtectedPlayer = false;
let collecting = false;
let collectingId = null
let task = null;
let isInitialSpawn = true;
let collecting_paused = false
let mcData;
let isEating = false;
let containerMemory = []
const EAT_THRESHOLD = 16;
let MODE = '–º–∏—Ä–Ω—ã–π';
let SOUND = null;
let defaultMove
let playing = false;
let latestBrokenBlock = [new vec3(0, 0, 0), 'air']

const SPAWN_POSITIONS = [
    new vec3(-8, 87, -2),
    new vec3(16, 87, -15),
    new vec3(4, 87, -23),
    new vec3(-9, 94, -25),
    new vec3(0, 94, -17),
    new vec3(3, 97, -6),
    new vec3(1, 87, 12),
    new vec3(-23, 86, -8),
    new vec3(-32, 86, -16),
    new vec3(-32, 86, 9),
    new vec3(-32, 86, 15),
    new vec3(-17, 86, 8),
    new vec3(-17, 86, 18),
    new vec3(11, 87, 6),
    new vec3(26, 87, 23),
    new vec3(41, 87, 24),
    new vec3(30, 86, 11),
    new vec3(-24, 89, 1),
    new vec3(-16, 86, -14),
    new vec3(-19, 91, -15),
    new vec3(-7, 87, -18),
    new vec3(3, 87, -17),
    new vec3(2, 87, 4),
    new vec3(-25, 91, 18),
    new vec3(-19, 94, 18),
    new vec3(-29, 100, 14),
    new vec3(-39, 97, 3),
    new vec3(-1, 92, 0),
    new vec3(-9, 90, -2),
    new vec3(-15, 88, 0),
    new vec3(-24, 90, -8),
    new vec3(-31, 89, 1),
    new vec3(-38, 87, 0),
    new vec3(-24, 89, 9),
    new vec3(-4, 93, -14),
    new vec3(18, 90, -6)
];

console.log(process.argv)

const BOT_USERNAME = process.argv[2] || process.env.BOT_USERNAME
const PASSWORD = process.argv[3] || process.env.PASSWORD
const NUMBER = parseInt(process.argv[4] || process.env.NUMBER)

console.log('----------------')
console.log('–°–≤–µ–¥–µ–Ω–∏—è –æ –±–æ—Ç–µ :')
console.log("–ò–º—è             :", BOT_USERNAME)
console.log("–ü–∞—Ä–æ–ª—å          :", PASSWORD)
console.log("–ü–æ—Ä—è–¥–∫–æ–≤—ã–π –Ω–æ–º–µ—Ä: ", NUMBER)
console.log('----------------')
//–≠–¢–û –ö–û–ú–ú–ï–ù–¢–ê–†–ò–ô –î–û–õ–ñ–ï–ù –ü–û–Ø–í–ò–¢–¨–°–Ø!
const bot = mineflayer.createBot({
    host: '212.80.7.178',
    port: 25565,
    username: BOT_USERNAME,
    auth: 'offline',
    version: '1.20.4'
});

console.log("–ó–∞–ø—É—Å–∫ –±–æ—Ç–∞...");

bot.loadPlugin(pathfinder);
bot.loadPlugin(pvp);
bot.loadPlugin(armorManager);
bot.loadPlugin(collectBlock);
bot.loadPlugin(toolPlugin);
bot.loadPlugin(movement.plugin)
bot.loadPlugin(plasmo.plugin)

function findFood(botInstance) {
    if (!mcData || !mcData.foods) {
        console.error("mcData –∏–ª–∏ mcData.foods –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω—ã!");
        return null;
    }
    return botInstance.inventory.items().find(item => mcData.foods[item.type]);
}

function sleep(ms) {
    const end = Date.now() + ms
    while (Date.now() < end) {
    }
}

function setLatestBrokenBlock(block) {
    if (!block) return;
    bpos = block.position
    latestBrokenBlock = [new vec3(bpos.x, bpos.y, bpos.z), block.name]
    console.log(latestBrokenBlock)
}

function hasRichItems() {
    const items = [
        ...bot.inventory.items(),
        bot.entity.heldItem,
        bot.inventory.slots[45],
        ...bot.inventory.slots.slice(5, 9)
    ].filter(item => item);

    return items.some(item =>
        RICH_ITEMS.some(keyword => item.name.toLowerCase().includes(keyword))
    );
}
async function stealItems(itemName, user_name) {
    const containers = containerMemory;
    if (containers.length === 0) {
        bot.chat("–ø–∞–º—è—Ç—å –ø—É—Å—Ç–∞—è.");
        return;
        return;
    }

    bot.chat(`–≤–∏–∂—É ${containers.length} –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–≤, —â–∞ —á–µ–∫–Ω—É —á—ë –≤ –Ω–∏—Ö`);

    for (const container of containers) {
        const { name, x, y, z, items } = container;

        const relevantItems = items.filter(item => item.name.toLowerCase().includes(itemName.toLowerCase()));

        if (relevantItems.length > 0) {
//            bot.chat(`–ù–∞—à–µ–ª –ø–æ–¥—Ö–æ–¥—è—â–∏–µ –ø—Ä–µ–¥–º–µ—Ç—ã –≤ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–µ ${name} (${x}, ${y}, ${z}), –∏–¥—É –∑–∞–±–∏—Ä–∞—Ç—å!`);

            try {
                await bot.pathfinder.goto(new GoalNear(Math.floor(x), Math.floor(y), Math.floor(z), 4));
//                await new Promise(res => setTimeout(res, 50));

                const block = bot.blockAt(new vec3(Math.floor(x), Math.floor(y), Math.floor(z)));
                if (!block) continue;

                const chest = await bot.openContainer(block);

                const removedItems = [];

                for (const item of chest.containerItems()) {
                    if (item.name.toLowerCase().includes(itemName.toLowerCase())) {
                        try {
                            await chest.withdraw(item.type, null, item.count);
                            console.log(`—É–∫—Ä–∞–ª ${item.name} x${item.count}`);
                            removedItems.push(item);
                        } catch (err) {
                            console.log(`–Ω–µ —Å–º–æ–≥ –∑–∞–±—Ä–∞—Ç—å ${item.name}:`, err.message);
                        }
                    }
                }

                chest.close();

                container.items = container.items.filter(item => !removedItems.includes(item));

//                bot.chat(`–£–¥–∞–ª–∏–ª ${removedItems.length} –ø—Ä–µ–¥–º–µ—Ç–æ–≤ –∏–∑ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ ${name}`);
            } catch (err) {
                console.log(`–æ—à–∏–±–∫–∞ —É ${name} –≤ –ø–æ–∑–∏—Ü–∏–∏ (${x}, ${y}, ${z}):`, err.message);
            }
        } else {
            console.log(`–í –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–µ ${name} –Ω–µ—Ç –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö –ø—Ä–µ–¥–º–µ—Ç–æ–≤.`);
        }
    }

    const target = bot.players[user_name]?.entity;
    if (!target) {
        bot.chat(`–Ω–µ –≤–∏–∂—É –∏–≥—Ä–æ–∫–∞ ${user_name}, –ª—É—Ç –ø—Ä–∏ –º–Ω–µ üòè`);
        return;
    }

//    bot.chat(`–∏–¥—É –∫ ${username} —Å –ª—É—Ç–æ–º`);
    await bot.pathfinder.goto(new GoalNear(target.position.x, target.position.y, target.position.z, 2));

    const items = bot.inventory.items();
    for (const item of items) {
        try {
            await bot.toss(item.type, null, item.count);
//            bot.chat(`–≤—ã–∫–∏–Ω—É–ª ${item.name} x${item.count}`);
        } catch (err) {
            console.log(`–Ω–µ —Å–º–æ–≥ —Å–∫–∏–Ω—É—Ç—å ${item.name}:`, err.message);
        }
    }

    bot.chat("–≤—Å—ë —Å–∫–∏–Ω—É–ª, —á–µ–∫–Ω–∏!");
}
async function autoEat() {
    if (isEating || !mcData) return;

    if (bot.food <= EAT_THRESHOLD) {
        const food = findFood(bot);
        if (food) {
            console.log(`[–ê–≤—Ç–æ–ï–¥–∞] –ì–æ–ª–æ–¥ ${bot.food}/${bot.foodSaturation}. –ù–∞–π–¥–µ–Ω–∞ –µ–¥–∞: ${food.name}. –ù–∞—á–∏–Ω–∞—é –µ—Å—Ç—å.`);
            isEating = true;
            try {
                await bot.equip(food, 'hand');
                console.log(`[–ê–≤—Ç–æ–ï–¥–∞] –í–∑—è–ª ${food.name} –≤ —Ä—É–∫—É.`);
                await bot.consume();
                console.log(`[–ê–≤—Ç–æ–ï–¥–∞] –ü–æ–µ–ª ${food.name}.`);
            } catch (err) {
                console.error(`[–ê–≤—Ç–æ–ï–¥–∞] –û—à–∏–±–∫–∞ –≤–æ –≤—Ä–µ–º—è –µ–¥—ã: ${err.message}`);
                try { await bot.unequip('hand'); } catch (unequipErr) {/* –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º */}
            } finally {
                isEating = false;
            }
        } else {
            console.log(`[–ê–≤—Ç–æ–ï–¥–∞] –ì–æ–ª–æ–¥ ${bot.food}/${bot.foodSaturation}, –Ω–æ –µ–¥—ã –≤ –∏–Ω–≤–µ–Ω—Ç–∞—Ä–µ –Ω–µ—Ç.`);
            // bot.chat(`/msg ${WATCHED_PLAYERS[0]} –î–∞–π—Ç–µ –µ–¥—ã—ã—ã..`)
        }
    }
}
function initializeBotState() {
    // console.log("–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è –±–æ—Ç–∞...");
    try {
        mcData = require('minecraft-data')(bot.version);
        if (!mcData) {
            console.error("–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å mcData –¥–ª—è –≤–µ—Ä—Å–∏–∏:", bot.version);

            return;
        }

        // console.log(`[mcData] –ó–∞–≥—Ä—É–∂–µ–Ω—ã –¥–∞–Ω–Ω—ã–µ –¥–ª—è Minecraft ${bot.version}. –ì–µ–Ω–µ—Ä–∏—Ä—É—é –∫–∞—Ä—Ç—É Protocol ID -> Item Name...`);
        itemProtocolIdMap = {};

        const itemsById = mcData.items;

        if (!itemsById) {
            // console.error("[mcData] –û—à–∏–±–∫–∞: –°–≤–æ–π—Å—Ç–≤–æ 'items' –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –≤ mcData. –ù–µ –º–æ–≥—É —Å–æ–∑–¥–∞—Ç—å –∫–∞—Ä—Ç—É ID.");
        } else {
            for (const protocolIdStr in itemsById) {
                if (Object.prototype.hasOwnProperty.call(itemsById, protocolIdStr)) {
                    const itemInfo = itemsById[protocolIdStr];
                    const numericProtocolId = parseInt(protocolIdStr, 10);

                    if (!isNaN(numericProtocolId) && itemInfo && itemInfo.name) {
                        itemProtocolIdMap[numericProtocolId] = itemInfo.name;
                    } else {
                        // console.warn(`[mcData] –ü—Ä–æ–ø—É—Å–∫ –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–π –∑–∞–ø–∏—Å–∏ –ø—Ä–µ–¥–º–µ—Ç–∞: ID='${protocolIdStr}', Info=`, itemInfo);
                    }
                }
            }
            // console.log(`[mcData] –ö–∞—Ä—Ç–∞ Protocol ID -> Item Name —Å–æ–∑–¥–∞–Ω–∞. –ù–∞–π–¥–µ–Ω–æ ${Object.keys(itemProtocolIdMap).length} –ø—Ä–µ–¥–º–µ—Ç–æ–≤.`);
            // console.log(`[mcData] –ü—Ä–æ–≤–µ—Ä–∫–∞: ID 854 = ${itemProtocolIdMap[854]}`);
        }

        defaultMove = new Movements(bot, mcData);


        defaultMove.speed = 10
        defaultMove.allow1by1towers = false
        // defaultMove.allowParkour = false
        defaultMove.canPlaceBlocks = false
        defaultMove.scafoldingBlocks = []
        defaultMove.canDig = false


        bot.pathfinder.setMovements(defaultMove);
        bot.pathfinder.setGoal(null);

        following = false;
        miningSand = false;
        followingProtectedPlayer = false;
        protectedPlayer = null;
        isEating = false;

        bot.armorManager.equipAll();

        bot.off('health', autoEat);
        bot.on('health', autoEat);

        // console.log("–°–æ—Å—Ç–æ—è–Ω–∏–µ –±–æ—Ç–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–æ.");

    } catch (error) {
        console.error("–û—à–∏–±–∫–∞ –≤–æ –≤—Ä–µ–º—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ —Å–æ—Å—Ç–æ—è–Ω–∏—è –±–æ—Ç–∞:", error);
    }
}

async function openBlockNoLook(block) {
    return new Promise((resolve, reject) => {
        if (!block || !block.position) return reject(new Error("invalid block"))

        const pos = block.position

        bot._client.write('block_place', {
            location: pos,
            direction: 1,
            hand: 0,
            cursorX: 0.5,
            cursorY: 1.0,
            cursorZ: 0.5,
            insideBlock: false
        })

        const listener = (window) => {
            bot.removeListener('windowOpen', listener)
            resolve(window)
        }

        bot.on('windowOpen', listener)

        setTimeout(() => {
            bot.removeListener('windowOpen', listener)
            reject(new Error("timeout"))
        }, 5000)
    })
}
async function breakBlockManually(block) {
    if (!block || !bot.canDigBlock(block)) {
        console.log('–ù—É —Ç–∏–ø... –Ω–µ –º–æ–≥—É —Å–ª–æ–º–∞—Ç—å —ç—Ç–æ—Ç –±–ª–æ–∫ :|');
        return;
    }

    try {
        await bot.tool.equipForBlock(block);
        await bot.dig(block);
        console.log(`–†—É—á–∫–∞–º–∏ —É–Ω–∏—á—Ç–æ–∂–∏–ª ${block.name}`);
    } catch (err) {
        console.log('–®–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫ –ø—Ä–∏ —Ä—É—á–Ω–æ–º —É–Ω–∏—á—Ç–æ–∂–µ–Ω–∏–∏: ', err.message);
    }
}
async function connectToServer() {
    console.log('–ü—ã—Ç–∞—é—Å—å –∑–∞–π—Ç–∏!');
    await new Promise(resolve => setTimeout(resolve, 500));
    bot.chat('/server sleepcraft');
}
async function sendFeedback(text) {
    for (const player of WATCHED_PLAYERS) {
        if (bot.players[player]) {
            await new Promise(resolve => setTimeout(resolve, 50));
            bot.chat(`/msg ${player} ${text}`);
        }
    }
}
async function replyFeedback(username, text) {
    bot.chat(`/msg ${username} ${text}`)
}
function equipItem(name) {
    const itemToEquip = bot.inventory.items().find(item => item.name.includes(name));
    if (itemToEquip && (!bot.heldItem || bot.heldItem.type !== itemToEquip.type)) {
        bot.equip(itemToEquip, 'hand').catch(err => console.log(`–û—à–∏–±–∫–∞ —ç–∫–∏–ø–∏—Ä–æ–≤–∫–∏: ${err.message}`));
    }
}
function selectIdsWithName(substring) {
    if (!itemProtocolIdMap || typeof itemProtocolIdMap !== 'object' || typeof substring !== 'string') {
        return [];
    }
    const lowerCaseSubstring = substring.toLowerCase();
    return Object.entries(itemProtocolIdMap)
        .filter(([idStr, itemName]) =>
            typeof itemName === 'string' && itemName.toLowerCase().includes(lowerCaseSubstring)
        )
        .map(([idStr, itemName]) => parseInt(idStr, 10));
}
async function collectBlockType(blockName, count) {
    if (!mcData) {
        console.log('No mcdata')
        miningSand = false;
        return;
    }

    let collected = 0;
    miningSand = true;
    async function mineNext() {
        if (collected >= count) {
            bot.chat(`/msg ${WATCHED_PLAYERS[0]} –ó–∞–≤–µ—Ä—à–∞—é.`);
            miningSand = false;
            task = null
            return;
        }

        const block = bot.findBlock({
            matching: block => {
                const nameMatches = block.name.toLowerCase().includes(blockName.toLowerCase())
                const isVisible = bot.canSeeBlock(block)
                return nameMatches && isVisible
            },
            maxDistance: 20,
            useExtraInfo: true
        })

        if (block) {
            try {
                console.log(`–ù–∞–π–¥–µ–Ω ${blockName} –≤ ${block.position}. –ò–¥—É –¥–æ–±—ã–≤–∞—Ç—å...`);

                if (block.name === 'chest' || block.name === 'torch' /* –∏ —Ç.–¥. */) {
                    await breakBlockManually(block);
                } else {
                    await bot.collectBlock.collect(block);
                }
                collected++;
                console.log(`–î–æ–±—ã—Ç–æ ${collected}/${count} ${blockName}.`);
                setTimeout(mineNext, 100);
            } catch (err) {
                bot.chat(`/msg ${WATCHED_PLAYERS[0]} –û—à–∏–±–∫–∞: ${err.message}`);
                console.error(`–û—à–∏–±–∫–∞ collectBlock:`, err);
                miningSand = false;
            }
        } else {
            bot.chat(`/msg ${WATCHED_PLAYERS[0]} –ù–µ—Ç.`);
            miningSand = false;
        }
    }

    mineNext();
}
function readFileWithRetry(filePath, maxAttempts = 40, delay = 200) {
    try {
        const content = fs.readFileSync(filePath, 'utf-8');
        if (content !== '') return content;
    } catch (err) {
        console.error(`–û—à–∏–±–∫–∞: ${err}`)
        return 'err'
    }
}
function readStates() {
    const directory = path.join('/rusvan-bots', 'states');
    const filesList = [];
    const files = fs.readdirSync(directory);

    files.forEach(filename => {
        if (filename.endsWith('.txt')) {
            const filePath = path.join(directory, filename);
            const content = readFileWithRetry(filePath);

            filesList.push({
                name: path.basename(filename, '.txt'),
                text: content
            });
        }
    });

    return filesList;
}
function getUsedIds() {
    const data = readStates();
    sorted = data
        .filter(obj => obj.name !== BOT_USERNAME)
        .map(obj => obj.text.split(':')[1])
        .filter(id => id !== 'null')
        .map(id => Number(id))
    // console.log(sorted)
    return sorted
}
function setState(text) {
    const botUsername = BOT_USERNAME;
    if (!botUsername) {
        console.error("BOT_USERNAME –Ω–µ –∑–∞–¥–∞–Ω.");
        return;
    }

    const filePath = path.join('/rusvan-bots/states', `${botUsername}.txt`);
    fs.writeFileSync(filePath, text, 'utf8')
    // console.log('–§–∞–π–ª –æ–±–Ω–æ–≤–ª–µ–Ω!!!')
}
setState(`null`)
console.log(`-----`)
console.log(readStates())
console.log(`-----`)


function findEntityWithName(bot, query, visible=true) {
    let targetQuery = query.toLowerCase();

    return bot.nearestEntity(entity => {
        const matchesCriteria = (
            (entity.type === 'player' && entity.username?.toLowerCase().includes(targetQuery)) ||
            (entity.type === 'mob' && entity.displayName?.toLowerCase().includes(targetQuery)) ||
            (entity.name?.toLowerCase().includes(targetQuery)) ||
            (entity.displayName?.toLowerCase().includes(targetQuery))
        );
        return visible ? (matchesCriteria && isEntityVisible(entity)) : matchesCriteria;
    });
}
function isEntityVisible(entity) {
    if (!entity || !bot.entity) return false;

    const botEyePosition = bot.entity.position.offset(0, bot.entity.height + 1, 0);
    const targetPosition = entity.position.offset(0, entity.height / 2, 0);
    const distance = botEyePosition.distanceTo(targetPosition);

    if (entity === bot.entity || distance > 128) {
        return false;
    }

    const direction = targetPosition.subtract(botEyePosition).normalize();

    try {
        const blockHit = bot.world.raycast(botEyePosition, direction, distance, (block) => {
            return block.boundingBox !== 'empty' && ![
                'glass', 'leaves', 'chest', 'torch', 'snow_layer'
            ].includes(block.name);
        });

        return blockHit === null;

    } catch (e) {
        console.error(`–û—à–∏–±–∫–∞ Raycast –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –≤–∏–¥–∏–º–æ—Å—Ç–∏ ${entity.username || entity.name || entity.displayName}:`, e);
        return false;
    }
}
function isEntityVisibleFromPos(fromPos, entity) {
    if (!entity) return false;

    const targetPosition = entity.position.offset(0, entity.height / 2, 0);
    const distance = fromPos.distanceTo(targetPosition);

    if (distance > 128) {
        return false;
    }

    const direction = targetPosition.subtract(fromPos).normalize();

    try {
        const blockHit = bot.world.raycast(fromPos, direction, distance, (block) => {
            return block.boundingBox !== 'empty' && ![
                'glass', 'leaves', 'chest', 'torch', 'snow_layer'
            ].includes(block.name);
        });

        return blockHit === null;

    } catch (e) {
        console.error(`‚ö†Ô∏è –û—à–∏–±–∫–∞ Raycast –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –≤–∏–¥–∏–º–æ—Å—Ç–∏ ${entity.username || entity.name || entity.displayName}:`, e);
        return false;
    }
}

function isItemOnSpawn(itemEntity) {
    if (!itemEntity || !itemEntity.position) return false;
    // console.log("–¢–µ—Å—Ç–∏–º –Ω–∞ –≤–∏–¥–∏–º–æ—Å—Ç—å!")
    return SPAWN_POSITIONS.some(spawnPos => {
        return isEntityVisibleFromPos(spawnPos, itemEntity);
    });
}

function processCommand(message, username, plainMessage) {

    const parts = message.trim().toLowerCase().split(" ");
    const command = parts[0];
    const args = parts.slice(1);

    // console.log(`username: '${username}', command: '${command}'`);

    switch (command) {
        case "exec":
            if (!WATCHED_PLAYERS.includes(username)) {
                sendFeedback(`${username} —Ö–æ—á–µ—Ç –≤—ã–ø–æ–ª–Ω–∏—Ç—å ${plainMessage}`)
                replyFeedback(username, `–Ø –Ω–µ –±—É–¥—É —ç—Ç–æ–≥–æ –¥–µ–ª–∞—Ç—å!!!`)
                return;
            }
            eval(message.split('exec ')[1]);
            // bot.chat("–ï—Å—Ç!");
            return;
        case "say":
            if (!WATCHED_PLAYERS.includes(username) && username !== '–í—ã') {
                sendFeedback(`${username} —Ö–æ—á–µ—Ç ${plainMessage}`)
            }
            bot.chat(message.includes('/') ? message.split('say ')[1] : `!${message.split('say ')[1]}`);
            return;
        case "activate":

            if (args.length < 1) {
                // bot.chat("–£–∫–∞–∂–∏ —Ü–µ–ª—å: activate <–Ω–∏–∫_–∏–≥—Ä–æ–∫–∞ | —Ç–∏–ø_–º–æ–±–∞>");
                return;
            }
            let targetname = args[0];

            sendFeedback(`–ò—â—É —Ü–µ–ª—å –¥–ª—è –ø–∫–º: ${targetname}`);
            bot.chat(`/msg ${username} –ò—â—É —Ü–µ–ª—å: ${targetname}`);

            const entityToActivate = findEntityWithName(bot, targetname);
            if (entityToActivate) {
                const headPosition = entityToActivate.position.offset(0, entityToActivate.height * 0.9, 0);
                bot.lookAt(headPosition);
                bot.activateEntity(entityToActivate);
            }
            return;
        case "activateblock":
            const blockToActivate = bot.findBlock({
                matching: block => {
                    const nameMatches = block.name.toLowerCase().includes(parts[1].toLowerCase())
                    const isVisible = bot.canSeeBlock(block)
                    return nameMatches && isVisible
                },
                maxDistance: 5,
                useExtraInfo: true
            })
            if (blockToActivate) {
                bot.lookAt(blockToActivate.position);
                bot.activateBlock(blockToActivate);
            }
            return;
        case "comeblock":
            const blockToCome = bot.findBlock({
                matching: block => {
                    const nameMatches = block.name.toLowerCase().includes(parts[1].toLowerCase())
                    // const isVisible = bot.canSeeBlock(block)
                    return nameMatches //&& isVisible
                },
                maxDistance: 50,
                useExtraInfo: true
            })
            if (blockToCome) {
                bot.pathfinder.setMovements(defaultMove);
                bot.pathfinder.setGoal(new goals.GoalBlock(blockToCome.position.x, blockToCome.position.y, blockToCome.position.z, 2))
                console.log('–ò–¥—É –∫ –±–ª–æ–∫—É')
            } else {
                bot.chat(`/m ${WATCHED_PLAYERS[0]} –ë–ª–æ–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω üò¢`)
                bot.chat(`/m ${username} –ë–ª–æ–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω üò¢`)
            }
            break;
        case 'restart':
            initializeBotState();

            if (isInitialSpawn) {
                // console.log("–ü–µ—Ä–≤—ã–π —Å–ø–∞–≤–Ω: –ó–∞–ø—É—Å–∫ –ø—Ä–æ—Ü–µ—Å—Å–∞ –≤—Ö–æ–¥–∞...");

            } else {
                bot.setControlState('sprint', true);
            }
            return;
        case "drop":
            if (!WATCHED_PLAYERS.includes(username)) {
                sendFeedback(`${username} —Ö–æ—á–µ—Ç —á—Ç–æ–±—ã —è ${plainMessage}`)
                bot.chat(`/msg ${username} –Ø –Ω–µ –±—É–¥—É —ç—Ç–æ–≥–æ –¥–µ–ª–∞—Ç—å!!!`)
                return;
            }

            ;(async () => {

            async function safeToss(item, amount) {
                const slot = item.slot
                if (slot < 9 || slot > 44) {
                    try {
                        await bot.equip(item, 'hand')
                        await bot.unequip('hand')
                    } catch (err) {
                        bot.chat(`/msg ${WATCHED_PLAYERS[0]} –Ω–µ —Å–º–æ–≥ —Å–Ω—è—Ç—å ${item.name}: ${err.message}`)
                        return
                    }
                }

                bot.toss(item.type, null, Math.min(item.count, amount), err => {
                    if (!err) {
                        // bot.chat(`/msg ${WATCHED_PLAYERS[0]} –≤—ã–±—Ä–æ—Å–∏–ª ${Math.min(item.count, amount)} ${item.name}`)
                    } else {
                        // bot.chat(`/msg ${WATCHED_PLAYERS[0]} –Ω–µ —Å–º–æ–≥ –≤—ã–∫–∏–Ω—É—Ç—å ${item.name}: ${err.message}`)
                    }
                })
            }

            for (let i = 1; i < parts.length; i += 2) {
                const itemName = parts[i].toLowerCase()
                const amount = parts[i + 1] === "all" ? Infinity : parseInt(parts[i + 1])

                const allItems = [
                    ...bot.inventory.items(),
                    bot.inventory.slots[45],
                    bot.inventory.slots[5],
                    bot.inventory.slots[6],
                    bot.inventory.slots[7],
                    bot.inventory.slots[8],
                ].filter(it => it)

                const matchingItems = allItems.filter(it => it.name.toLowerCase().includes(itemName))

                if (matchingItems.length > 0) {
                    for (const item of matchingItems) {
                        await safeToss(item, amount)
                    }
                } else {
                    bot.chat(`/msg ${WATCHED_PLAYERS[0]} —É –º–µ–Ω—è –Ω–µ—Ç –Ω–∏—á–µ–≥–æ —Ç–∏–ø–∞ '${itemName}'`)
                    bot.chat(`/msg ${username} —É –º–µ–Ω—è –Ω–µ—Ç –Ω–∏—á–µ–≥–æ —Ç–∏–ø–∞ '${itemName}'`)
                }
            }

        })()
            return;
        case "collect":
            if (task) {
                bot.chat(`/msg ${WATCHED_PLAYERS[0]} –Ø —É–∂–µ –∑–∞–Ω—è—Ç –∑–∞–¥–∞–Ω–∏–µ–º ${task}`);
                bot.chat(`/msg ${username} –Ø —É–∂–µ –∑–∞–Ω—è—Ç –∑–∞–¥–∞–Ω–∏–µ–º ${task}`);
                return;
            }

//                bot.on('entityHurt', async (entity) => {
//
//                    if (entity === bot.entity) {
//                        // bot.chat('–ü–æ–ª—É—á–µ–Ω —É—Ä–æ–Ω :(')
//                        console.log('–ú–µ–Ω—è –∞—Ç–∞–∫—É—é—Ç!');
//
//                        bot.pathfinder.setGoal(null);
//
//                        const nearestEntity = bot.nearestEntity(entity =>
//                            entity !== bot.entity && isEntityVisible(entity) && !entity.name.includes('item') && !entity.name.includes('stand')
//                        );
//                        // bot.chat('–Ø –∑–Ω–∞—é, –∫—Ç–æ —É–¥–∞—Ä–∏–ª!')
//                        if (nearestEntity) {
//                            collecting_paused = true;
//                            console.log(`–ê—Ç–∞–∫—É—é —Å—É—â–Ω–æ—Å—Ç—å: ${nearestEntity.name}`);
//                            bot.pathfinder.setMovements(defaultMove);
//                            bot.pathfinder.setGoal(null)
//                            bot.pathfinder.setGoal(new goals.GoalFollow(nearestEntity, 0));
//                            bot.pvp.attack(nearestEntity);  // –ê—Ç–∞–∫—É–µ–º —Å—É—â–Ω–æ—Å—Ç—å
//
//
//
//                            const healthChecker = setInterval(() => {
//                                if (!isEntityVisible(nearestEntity)) {
//                                    console.log(`${nearestEntity.name} —É–±–∏—Ç–∞!`);
//                                    // bot.chat('–•–∞! —è –ø–æ–±–µ–¥–∏–ª!')
//                                    collecting_paused = false;
//                                    collecting_paused = false;
//                                    bot.pvp.stop()
//                                    clearInterval(healthChecker);
//
//
//                                } else {
//                                    const campsword = bot.inventory.items().find(item => item.name.includes("sword"));
//                                    if (campsword && (!bot.heldItem || bot.heldItem.type !== campsword.type)) {
//                                        bot.equip(campsword, 'hand').catch(err => console.log(`–û—à–∏–±–∫–∞ —ç–∫–∏–ø–∏—Ä–æ–≤–∫–∏ –º–µ—á–∞: ${err.message}`));
//                                    }
//
//                                }
//                            }, 500);
//
//                        const onEntityGone = (goneEntity) => {
//                            if (goneEntity === nearestEntity) {
//                                console.log(`${goneEntity.name} –∏—Å—á–µ–∑–ª–∞ –∏–ª–∏ —É–±–∏—Ç–∞!`);
//                                collecting_paused = false;
//                                bot.pvp.stop();
//                                clearInterval(healthChecker);
//                                bot.pathfinder.setMovements(defaultMove);
//                                bot.pathfinder.setGoal(null);
//                            }
//                        };
//
//                        bot.once('entityGone', onEntityGone);
//                        } else {
//                            collecting_paused = false;
//                            console.log('–ù–µ—Ç –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö —Å—É—â–Ω–æ—Å—Ç–µ–π –¥–ª—è –∞—Ç–∞–∫–∏');
//                        }
//                    }
//                });
        function findNearestItem(searchName = '') {
            wanted_ids = []
            if (searchName) {
                wanted_ids = selectIdsWithName(searchName);
            }
            return bot.nearestEntity(entity => {
                if (searchName) {
                    if (wanted_ids.includes(entity?.metadata?.[8]?.itemId) && entity?.metadata?.[8]?.present && entity.name === 'item' && (isItemOnSpawn(entity)  || isEntityVisible(entity)) && !getUsedIds().includes(entity.id)) {
                        return true;
                    }
                } else {
                    return entity.name === 'item' && entity?.metadata?.[8]?.present && (isItemOnSpawn(entity) || isEntityVisible(entity)) && !getUsedIds().includes(entity.id);
                }
            });
        }

        function isFarFromCenter() {
            const pos = bot.entity.position;
            const dx = pos.x;
            const dz = pos.z;
            return Math.sqrt(dx * dx + dz * dz) > 15;
        }

        async function unequipArmorAndMainHand() {
            for (let i = 0; i < 4; i++) {
                const armorItem = bot.inventory.slots[i + 5];
                if (armorItem) {
                    await bot.equip(armorItem, 'hand');
                }
            }

            const mainHandItem = bot.inventory.slots[36];
            if (mainHandItem) {
                await bot.equip(mainHandItem, 'hand');
            }
        }
        async function depositItems() {
            if (justCheckedBarrel) {return}
            console.log('–ó–∞–ø—É—Å–∫ –æ—á–∏—Å—Ç–∫–∏...')



            justCheckedBarrel = true
            chestPos = vec3(6.5, 88, 6.5);
            await bot.pathfinder.goto(new goals.GoalNear(chestPos.x, chestPos.y, chestPos.z, 1));

            const blocks = bot.findBlocks({
                matching: block => block.name.includes('barrel'),
                maxDistance: 4,
                count: 5,
            })

            if (hasRichItems()) {
                console.log("—É –º–µ–Ω—è –µ—Å—Ç—å —Ü–µ–Ω–Ω—ã–µ –≤–µ—â–∏")
                const chestBlock_rich = blocks
                    .map(pos => bot.blockAt(pos))
                    .find(block => block && block.position.y === 86 && block.position.z === 8)
                if (!chestBlock_rich) {
                    bot.chat(`/msg ${username} –Ω–µ –Ω–∞—à–µ–ª –±–æ—á–∫—É :(`);
                    return;
                }

                await unequipArmorAndMainHand()

                // const blockToLookAt_rich = bot.findBlock({
                //     matching: block => {
                //         const nameMatches = block.name.toLowerCase().includes('calcite');
                //         const isVisible = bot.canSeeBlock(block);
                //         return nameMatches && isVisible;
                //     },
                //     maxDistance: 5,
                //     useExtraInfo: true
                // });
                //
                // if (blockToLookAt_rich) {
                //     const center_rich = blockToLookAt_rich.position.offset(0.5, 0.5, 0.5);
                //     await bot.lookAt(center_rich, true);
                // }

                const chest_rich = await bot.openBlock(chestBlock_rich, null);

                for (let item of bot.inventory.items()) {
                    if (RICH_ITEMS.some(keyword => item.name.includes(keyword))) {                        try {
                            console.log(`–ö–ª–∞–¥—É ${item.name}`)
                            await chest_rich.deposit(item.type, null, item.count);
                        } catch (err) {
                            console.log(`–ù–µ —Å–º–æ–≥ –ø–æ–ª–æ–∂–∏—Ç—å ${item.name}: ${err.message}`);
                        }
                    }
                }
                chest_rich.close();
            }

            const chestBlock = blocks
                .map(pos => bot.blockAt(pos))
                .find(block => block && block.position.z === 6 && block.position.y === 86 )

            // console.log(`Distnace to barrel: ${bot.entity.position.distanceTo(chestPos)}`);
            if (!chestBlock) {
                bot.chat(`/msg ${username} –Ω–µ –Ω–∞—à–µ–ª –±–æ—á–∫—É :(`);
                return;
            }


            const chest = await bot.openBlock(chestBlock, null);
            console.log('–ú—É—Å–æ—Ä–∫–∞ –æ—Ç–∫—Ä—ã—Ç–∞')
            for (let item of bot.inventory.items()) {
                if (!item.name.includes('beef') && !item.name.includes('pork') && !item.name.includes('chicken') && !item.name.includes('bread') && !item.name.includes('mutt') && !item.name.includes('sword')) {
                    try {
                        console.log(`–ö–ª–∞–¥—É ${item.name}`)
                        await chest.deposit(item.type, null, item.count);
                    } catch (err) {
                        console.log(`–ù–µ —Å–º–æ–≥ –ø–æ–ª–æ–∂–∏—Ç—å ${item.name}: ${err.message}`);
                    }
                }
            }

            const blockToLookAt = bot.findBlock({
                matching: block => {
                    const nameMatches = block.name.toLowerCase().includes('calcite');
                    const isVisible = bot.canSeeBlock(block);
                    return nameMatches && isVisible;
                },
                maxDistance: 5,
                useExtraInfo: true
            });

            if (blockToLookAt) {
                const center = blockToLookAt.position.offset(0.5, 0.5, 0.5);
                await bot.lookAt(center, true);
            }

            chest.close();
        }
            justCheckedBarrel = true;
            let collectInterval = null;

        function startCollecting(searchName = '') {
            if (collectInterval) clearInterval(collectInterval);

            task = 'collecting';

            collectInterval = setInterval(async () => {
                // if (collecting_paused) {
                //     console.log('–°–±–æ—Ä –ø—Ä–∏–æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω, –∂–¥—É 5 —Å–µ–∫—É–Ω–¥...');
                //     await new Promise(resolve => setTimeout(resolve, 5000));
                //     return;
                // }
                const targetItem = findNearestItem(searchName);

                console.log('targetItem ', targetItem);
                console.log(bot.pathfinder.goal);

                if (targetItem && !bot.pathfinder.goal) {
                    setState(`collecting:${targetItem.id}`);
                    console.log('–ù–æ—Ä–º–∞–ª—å–Ω—ã–π –ø—Ä–µ–¥–º–µ—Ç detetcted!')
                    bot.pathfinder.setMovements(defaultMove);
                    id = targetItem?.metadata?.[8]?.itemId
                    count = targetItem?.metadata?.[8]?.itemCount
                    console.log(`ID: ${id}, —Ç–∏–ø: ${itemProtocolIdMap[id]}, –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ ${count}`);
                    // console.log(JSON.stringify(targetItem.metadata, null, 2));
                    justCheckedBarrel = false;
                    bot.chat(`/msg ${WATCHED_PLAYERS[0]} –ò–¥—É!`)
                    bot.pathfinder.setMovements(defaultMove);
                    bot.pathfinder.setGoal(null)
                    bot.pathfinder.setGoal(new GoalFollow(targetItem, 0));
                } else {
                    if (isFarFromCenter() && !bot.pathfinder.goal) {
                        bot.chat(`/msg ${WATCHED_PLAYERS[0]} –í–æ–∑–≤—Ä–∞—â–∞—é—Å—å –Ω–∞ –±–∞–∑—É..`)
                        chestPos = vec3(7, 87, 6);
                        await bot.pathfinder.goto(new goals.GoalNear(chestPos.x, chestPos.y, chestPos.z, 2));
                    } else if (!justCheckedBarrel && !bot.pathfinder.goal) {
                        await depositItems();
                        bot.chat(`/msg ${WATCHED_PLAYERS[0]} –ú—É—Å–æ—Ä —Å–æ–±—Ä–∞–Ω!`)
                        // blockToLookAfterDeposit = bot.findBlock({
                        //     matching: block => {
                        //         const nameMatches = block.name.toLowerCase().includes('calcite')
                        //         const isVisible = bot.canSeeBlock(block)
                        //         return nameMatches && isVisible
                        //     },
                        //     maxDistance: 5,
                        //     useExtraInfo: true
                        // })
                        // if (blockToLookAfterDeposit) {
                        //     bot.lookAt(blockToLookAfterDeposit.position, true );
                        // }
                        bot.pathfinder.setGoal(new goals.GoalNear(7, 87, 6, 2 ));
                    }
                }

                if (!collecting) {
                    bot.chat(`/msg ${WATCHED_PLAYERS[0]} –ø—Ä–µ–∫—Ä–∞—â–∞—é!`);
                    if (collectInterval) clearInterval(collectInterval);
                    bot.pathfinder.setGoal(null);
                    return;
                }

            }, 1000);
        }

            const searchName = parts[1]
            console.log(searchName)
            collecting = true;
            startCollecting(searchName);
            break;

        case "piglins":
            if (task) {
                bot.chat(`/msg ${WATCHED_PLAYERS[0]} –Ø —É–∂–µ –∑–∞–Ω—è—Ç –∑–∞–¥–∞–Ω–∏–µ–º ${task}`)
                bot.chat(`/msg ${username} –Ø —É–∂–µ –∑–∞–Ω—è—Ç –∑–∞–¥–∞–Ω–∏–µ–º ${task}`)
                return;
            }

            if (MODE === "–º–∏—Ä–Ω—ã–π") {
                bot.chat(`/msg ${username} –Ø —Å–µ–≥–æ–¥–Ω—è –¥–æ–±—Ä—ã–π!`)
                return;
            }

            bot.chat(`/msg ${username} –Ω–∞—á–∏–Ω–∞—é —Ä–∞–∑–¥—Ä–∞–∂–∞—Ç—å –ø–∏–≥–ª–∏–Ω–æ–≤ :)))`);

            task = "piglins";

            const PIGLIN_ATTACK_INTERVAL = 400;
            const MAX_PIGLIN_ATTEMPTS = 100;
            let piglinAttempts = 0;
            let piglinInterval = null;

        function findNearestPiglin() {
            const mobs = Object.values(bot.entities).filter(e =>
                e.name?.includes("piglin") && e.type === "mob" && e.isValid
            );

            if (mobs.length === 0) return null;

            mobs.sort((a, b) =>
                bot.entity.position.distanceTo(a.position) - bot.entity.position.distanceTo(b.position)
            );

            return mobs[0];
        }

        function stopPiglinTask() {
            if (piglinInterval) clearInterval(piglinInterval);
            bot.chat(`/msg ${username} –ü–∏–≥–ª–∏–Ω—ã –æ—Ç–º—É—á–∏–ª–∏—Å—å`);
            task = null;
        }

            piglinInterval = setInterval(() => {
                const target = findNearestPiglin();

                if (!target || piglinAttempts >= MAX_PIGLIN_ATTEMPTS) {
                    stopPiglinTask();
                    return;
                }

                if (bot.entity.position.distanceTo(target.position) <= 4 && target.isValid) {
                    bot.lookAt(target.position.offset(0, 1.5, 0), true).then(() => {
                        bot.attack(target);
                    }).catch(() => {});
                }

                piglinAttempts++;
            }, PIGLIN_ATTACK_INTERVAL);

            break;


        case "camp":
            if (task) {
                bot.chat(`/msg ${WATCHED_PLAYERS[0]} –Ø —É–∂–µ –∑–∞–Ω—è—Ç –∑–∞–¥–∞–Ω–∏–µ–º ${task}`)
                bot.chat(`/msg ${username} –Ø —É–∂–µ –∑–∞–Ω—è—Ç –∑–∞–¥–∞–Ω–∏–µ–º ${task}`)
                return;
            }


            if (args.length < 1) {
                bot.chat(`/msg ${username} –£–∫–∞–∂–∏ —Ü–µ–ª—å: camp <–Ω–∏–∫_–∏–≥—Ä–æ–∫–∞ | —Ç–∏–ø_–º–æ–±–∞>`);
                return;
            }
            if (MODE === "–º–∏—Ä–Ω—ã–π") {
                bot.chat(`/msg ${username} –Ø —Å–µ–≥–æ–¥–Ω—è –¥–æ–±—Ä—ã–π!`)
                return;
            }
            let camptargetUsername = args[0];
            if (camptargetUsername === 'vlkardakov') {
                // bot.chat(–ù–µ—Ç –∏–¥–∏—Ç–µ –Ω–∞—Ñ–∏–≥')
                return;
            }
            bot.chat(`/msg ${WATCHED_PLAYERS[0]} –ò—â—É —Ü–µ–ª—å: ${camptargetUsername}`);
            bot.chat(`/msg ${username} –ò—â—É —Ü–µ–ª—å: ${camptargetUsername}`);
            task = 'camp'

        function findNewTarget() {
            return findEntityWithName(bot, camptargetUsername, visible=false);
        }

        function startCampAttack(targetEntity) {
            if (!targetEntity) {
                bot.chat(`/msg ${WATCHED_PLAYERS[0]} –ù–µ –Ω–∞–π–¥–µ–Ω–∞ —Å—É—â–Ω–æ—Å—Ç—å: ${camptargetUsername}.`);
                task = null
                return;
            }

            const camptargetName = targetEntity.username || targetEntity.displayName || targetEntity.name || '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è —Å—É—â–Ω–æ—Å—Ç—å';

            // bot.pathfinder.setGoal(null);
            // bot.pvp.stop();
            // bot.pathfinder.setMovements(defaultMove);
            // bot.pathfinder.setGoal(new GoalFollow(targetEntity, RANGE_GOAL), true);

            let campattackInterval = null;
            const campMAX_ATTEMPTS = 250;
            let campattackAttempts = 0;

            function campattackLoop() {
                if (!targetEntity || !targetEntity.isValid || campattackAttempts >= campMAX_ATTEMPTS) {
                    bot.chat(`/msg ${WATCHED_PLAYERS[0]} –•–∞—Ö–∞—Ö–∞ –Ω–∏—á—Ç–æ–∂–µ—Å—Ç–≤–æ /s`);
                    bot.pathfinder.setGoal(null);
                    bot.pvp.stop();
                    if (campattackInterval) clearInterval(campattackInterval);


                    const newTarget = findNewTarget();
                    if (newTarget && newTarget !== targetEntity) {
                        startCampAttack(newTarget);
                    }
                    task = null;
                    return;
                }
                bot.on('message', (jsonMsg, position) => {
                    if (jsonMsg.toString().includes('stop')) {
                        bot.pathfinder.setGoal(null);
                        bot.pvp.stop();
                        if (campattackInterval) clearInterval(campattackInterval);
                        task = null;
                        return;
                    }
                })

                const campsword = bot.inventory.items().find(item => item.name.includes("sword"));
                if (campsword && (!bot.heldItem || bot.heldItem.type !== campsword.type)) {
                    bot.equip(campsword, 'hand').catch(err => console.log(`–û—à–∏–±–∫–∞ —ç–∫–∏–ø–∏—Ä–æ–≤–∫–∏ –º–µ—á–∞: ${err.message}`));
                }

                if (command === 'kill' && !isEntityVisible(targetEntity)) {
                } else {
                    bot.pvp.attack(targetEntity);
                }

                campattackAttempts++;
            }

            campattackInterval = setInterval(campattackLoop, 500);
        }

            const initialTarget = findNewTarget();
            startCampAttack(initialTarget);
            break;
        case "kill":
            if (task) {
                bot.chat(`/msg ${username} –Ø —É–∂–µ –∑–∞–Ω—è—Ç –∑–∞–¥–∞–Ω–∏–µ–º ${task}`)
                bot.chat(`/msg ${WATCHED_PLAYERS[0]} –Ø —É–∂–µ –∑–∞–Ω—è—Ç –∑–∞–¥–∞–Ω–∏–µ–º ${task}`)
                return;
            }

            if (MODE === "–º–∏—Ä–Ω—ã–π") {
                bot.chat(`/msg ${WATCHED_PLAYERS[0]} –Ø —Å–µ–≥–æ–¥–Ω—è –¥–æ–±—Ä—ã–π!`)
                bot.chat(`/msg ${username} –Ø —Å–µ–≥–æ–¥–Ω—è –¥–æ–±—Ä—ã–π!`)
                return;
            }
            if (args.length < 1) {
                bot.chat(`/msg ${WATCHED_PLAYERS[0]} –£–∫–∞–∂–∏ —Ü–µ–ª—å: attack/kill <–Ω–∏–∫_–∏–≥—Ä–æ–∫–∞ | —Ç–∏–ø_–º–æ–±–∞>`);
                bot.chat(`/msg ${username} –£–∫–∞–∂–∏ —Ü–µ–ª—å: attack/kill <–Ω–∏–∫_–∏–≥—Ä–æ–∫–∞ | —Ç–∏–ø_–º–æ–±–∞>`);
                return;
            }
            let targetUsername = args[0];
            if (targetUsername === 'enemy') targetUsername = 'zombie';

            if (targetUsername === 'vlkardakov') {
                bot.chat(`/msg ${username} –ù–µ—Ç –∏–¥–∏—Ç–µ –Ω–∞—Ñ–∏–≥`)
                return;}

            targetEntity = findEntityWithName(bot, targetUsername);

            if (!targetEntity) {
                bot.chat(`/msg ${username} –ù–µ ${command === 'kill' ? '–≤–∏–∂—É' : '–Ω–∞–π–¥–µ–Ω–∞'} —Å—É—â–Ω–æ—Å—Ç—å: ${targetUsername}.`);
                bot.chat(`/msg ${WATCHED_PLAYERS[0]} –ù–µ ${command === 'kill' ? '–≤–∏–∂—É' : '–Ω–∞–π–¥–µ–Ω–∞'} —Å—É—â–Ω–æ—Å—Ç—å: ${targetUsername}.`);
                return;
            }
            bot.pathfinder.setGoal(null);
            equipItem('axe')
            equipItem('sword')
            bot.pvp.attack(targetEntity);
            break;
        case "remember":
            if (task) {
                bot.chat(`/msg ${WATCHED_PLAYERS[0]} –Ø —É–∂–µ –∑–∞–Ω—è—Ç –∑–∞–¥–∞–Ω–∏–µ–º ${task}`)
                bot.chat(`/msg ${username} –Ø —É–∂–µ –∑–∞–Ω—è—Ç –∑–∞–¥–∞–Ω–∏–µ–º ${task}`)
                return;
            }

            task = 'remembering'

            const rememberContainers = async () => {
                const radius = parseInt(parts[1]) || 15

                let blocks = bot.findBlocks({
                    matching: block => {
                        return (
                            block &&
                            block.name.toLowerCase().includes("barrel")
                        )
                    },
                    maxDistance: radius,
                    count: 999
                })

                const getDistance = (block1, block2) => {
                    if (!block1.position || !block2.position) return Infinity;

                    return Math.sqrt(
                        Math.pow(block1.position.x - block2.position.x, 2) +
                        Math.pow(block1.position.y - block2.position.y, 2) +
                        Math.pow(block1.position.z - block2.position.z, 2)
                    )
                }

                let currentBlock = blocks[0]
                let remainingBlocks = blocks.slice(1)

                remainingBlocks.sort((a, b) => getDistance(bot.entity, a) - getDistance(bot.entity, b))

                blocks = [currentBlock]
                while (remainingBlocks.length > 0 && (task === 'remembering')) {
                    let nearestBlock = remainingBlocks[0]
                    remainingBlocks.forEach(block => {
                        if (getDistance(currentBlock, block) < getDistance(currentBlock, nearestBlock)) {
                            nearestBlock = block
                        }
                    })

                    blocks.push(nearestBlock)

                    currentBlock = nearestBlock

                    remainingBlocks = remainingBlocks.filter(block => block !== nearestBlock)
                }

                const memoryData = []

                for (let pos of blocks) {
                    const block = bot.blockAt(pos)
                    if (task !== 'remembering') {break}
                    if (!block || !block.position) continue

                    try {
                        await bot.pathfinder.goto(new GoalNear(Math.floor(pos.x), Math.floor(pos.y), Math.floor(pos.z), 4))

                        const container = await bot.openContainer(block)
                        const items = container.slots.filter(slot => slot && slot.name) // –ü–æ–ª—É—á–∞–µ–º –ø—Ä–µ–¥–º–µ—Ç—ã –∏–∑ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
                        const itemsData = items.map(item => ({
                            name: item.name,
                            count: item.count
                        }))

                        memoryData.push({
                            name: block.name,
                            x: block.position.x,
                            y: block.position.y,
                            z: block.position.z,
                            items: itemsData
                        })

                        container.close()
                    } catch (err) {
                        console.log(`–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –≤ –ø–æ–∑–∏—Ü–∏–∏ ${block.position}: ${err.message}`)
                    }
                }

                containerMemory = memoryData
                console.table(memoryData)
                memoryData.forEach(container => {
                    console.log(`–ö–æ–Ω—Ç–µ–π–Ω–µ—Ä: ${container.name} (x: ${container.x}, y: ${container.y}, z: ${container.z})`)

                    if (container.items && container.items.length > 0) {
                        console.log(`  –°–æ–¥–µ—Ä–∂–∏–º–æ–µ:`)
                        container.items.forEach(item => {
                            console.log(`    - ${item.name} x${item.count}`)
                        })
                    } else {
                        console.log(`  –ù–µ—Ç –ø—Ä–µ–¥–º–µ—Ç–æ–≤ –≤ —ç—Ç–æ–º –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–µ`)
                    }
                })

                bot.chat(`/msg ${WATCHED_PLAYERS[0]} –ó–∞–ø–æ–º–Ω–∏–ª ${memoryData.length} –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–≤ —Å –ø—Ä–µ–¥–º–µ—Ç–∞–º–∏!`)
                bot.chat(`/msg ${username} –ó–∞–ø–æ–º–Ω–∏–ª ${memoryData.length} –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–≤ —Å –ø—Ä–µ–¥–º–µ—Ç–∞–º–∏!`)
                task = null
            }

            rememberContainers()
            break
        case "steal":
            const itemName = parts[1]
            if (!itemName) {
                bot.chat("—á–µ –≤–æ—Ä–æ–≤–∞—Ç—å-—Ç–æ? –≤–≤–µ–¥–∏ —á—ë—Ç —Ç–∏–ø–∞: steal diamond")
                return
            }

            stealItems(itemName, username)
            break
        case "addspawnpos":
            const pos = bot.players[username].entity.position.floored();
            SPAWN_POSITIONS.push(pos);
            bot.chat(`/msg ${username} –î–æ–±–∞–≤–∏–ª –ø–æ–∑–∏—Ü–∏—é: ${pos.x}, ${pos.y}, ${pos.z}`);
            break;
        case "logspawnpos":
            console.log('–°–ø–∞–≤–Ω–∞ –ø–æ–∑–∏—Ü–∏ —â–∞–ø—Ä–æ—à–µ–Ω—ã')
            if (SPAWN_POSITIONS.length === 0) {
                bot.chat(`/msg ${username} –°–ø–∞—É–Ω–æ–≤ –Ω–µ—Ç üò¢`);
            } else {
                console.log("const SPAWN_POSITIONS = [");
                SPAWN_POSITIONS.forEach((pos) => {
                    console.log(`    new vec3(${pos.x}, ${pos.y}, ${pos.z}),`);
                });
                console.log("];");

                bot.chat(`/msg ${username} –°–º–æ—Ç—Ä–∏ –∫–æ–Ω—Å–æ–ª—å`);
            }
            break;
        case "play":
            console.log('–ü—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –º—É–∑—ã–∫–∏ –∑–∞–ø—Ä–æ—à–µ–Ω–æ');
            if (SOUND || playing) {
                bot.chat(`/msg ${username} –Ø —É–∂–µ –∏–≥—Ä–∞—é ${SOUND}`);
                return;
            }

            SOUND = args[0] || "vivalavida";


            const ffmpeg = require('fluent-ffmpeg');
            const fs = require('fs');
            const path = require('path');


            let audioFile;
            try {
                audioFile = path.join('/rusvan-bots/music', `${SOUND}.mp3`);
                if (!fs.existsSync(audioFile)) {
                    console.error('–§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω:', audioFile);
                    bot.chat(`/msg ${username} —Ç—ã –ø—Ä–æ—Å–∏—à—å –Ω–µ—Å—É—â–µ—Å—Ç–≤—É—é—â—É—é –º—É–∑—ã–∫—É!!`)
                    SOUND = null;
                    playing = false;
                    return;
                }
            } catch (err) {
                console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ —Ñ–∞–π–ª–∞:', err);
                SOUND = null;
                playing = false;
                return;
            }

            const tempDir = path.join('/rusvan-bots/music', `temp_audio${NUMBER}`);
            playing = true;
            ffmpeg.ffprobe(audioFile, (err, metadata) => {
                if (err) {
                    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∞–Ω–∞–ª–∏–∑–µ –∞—É–¥–∏–æ—Ñ–∞–π–ª–∞:', err);
                    return;
                }

                const duration = metadata.format.duration;
                const segmentCount = Math.ceil(duration) / 4;

                console.log(`–†–∞–∑–¥–µ–ª–µ–Ω–∏–µ –∞—É–¥–∏–æ –Ω–∞ ${segmentCount} —Å–µ–≥–º–µ–Ω—Ç–æ–≤ –ø–æ 1 —Å–µ–∫—É–Ω–¥–µ`);

                ffmpeg(audioFile)
                    .outputOptions([
                        '-f segment',
                        '-segment_time 4',
                        '-c copy',
                        '-map 0:a'
                    ])
                    .output(`${tempDir}/segment-%03d.mp3`)
                    .on('end', () => {
                        console.log('–ê—É–¥–∏–æ —É—Å–ø–µ—à–Ω–æ —Ä–∞–∑–¥–µ–ª–µ–Ω–æ');

                        sendSegmentsSequentially(0, segmentCount, tempDir);
                    })
                    .on('error', (err) => {
                        console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–∏ –∞—É–¥–∏–æ:', err);
                    })
                    .run();
            });

        function sendSegmentsSequentially(index, total, tempDir) {
            if (index >= total || !playing) {
                console.log('–í—Å–µ —Å–µ–≥–º–µ–Ω—Ç—ã –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã');
                bot.chat(`/msg ${WATCHED_PLAYERS[0]} –Ø –∑–∞–∫–æ–Ω—á–∏–ª –∏–≥—Ä–∞—Ç—å!`)
                SOUND = null;
                playing = false;
                fs.readdirSync(tempDir).forEach(file => {
                    fs.unlinkSync(path.join(tempDir, file));
                });
                playing = false;
                return;
            }

            const segmentFile = path.join(tempDir, `segment-${index.toString().padStart(3, '0')}.mp3`);

            bot.plasmovoice.sendAudio(segmentFile)
                .then(() => {
                    // console.log(`–û—Ç–ø—Ä–∞–≤–ª–µ–Ω —Å–µ–≥–º–µ–Ω—Ç ${index + 1}/${total}`);
                    setTimeout(() => {
                        sendSegmentsSequentially(index + 1, total, tempDir);
                    }, 4000);
                })
                .catch(err => {
                    console.error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Å–µ–≥–º–µ–Ω—Ç–∞ ${index + 1}:`, err);
                    sendSegmentsSequentially(index + 1, total, tempDir);
                });
        }
            break;
        case "hi":
            bot.chat(`/msg ${username} –ü—Ä–∏–≤–µ—Ç–∞!`);
            break
        case "chosecolor":
            const targetBlock = bot.findBlock({
                matching: () => true,
                maxDistance: 4
            })

            if (!targetBlock) {
                bot.chat(`/msg ${username} –ë–ª–æ–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω`)
                break
            }

            bot.setControlState('sneak', true)

            bot.activateBlock(targetBlock)

            bot.once('windowOpen', async (window) => {
                const wanted = args[0]?.toLowerCase()
                if (!wanted) {
                    bot.chat(`/msg ${username} —Ü–≤–µ—Ç –Ω–µ –∑–∞–¥–∞–Ω`)
                    bot.closeWindow(window)
                    bot.setControlState('sneak', false)
                    return
                }

                for (let i = 0; i < window.slots.length; i++) {
                    const item = window.slots[i]
                    if (item && item.name.toLowerCase().includes(wanted)) {
                        try {
                            await bot.clickWindow(i, 0, 0)
                            await bot.waitForTicks(2)
                        } catch (err) {
                            console.log("–û—à–∏–±–∫–∞ –ø—Ä–∏ –∫–ª–∏–∫–µ:", err)
                        }
                    }
                }

                bot.closeWindow(window)
                bot.setControlState('sneak', false)
            })
            break
        case "drawto":
        console.log(`–ë—É–¥—É –∏—Å–∫–∞—Ç—å –≤—Å–µ –∫—Ä–æ–º–µ ${args[0]}`)
            async function drawLoop() {
            const block = bot.findBlock({
                matching: (b) => b?.name?.includes('wool') && !b.name.includes(args[0]),
                maxDistance: 32
            })

            if (!block) {
                bot.chat(`/msg ${username} –±–ª–æ–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω`)
                return
            }

            try {
                bot.activateBlock(block)
            } catch (e) {
                console.log("–æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø—É—Ç–∏ –∏–ª–∏ –∞–∫—Ç–∏–≤–∞—Ü–∏–∏:", e)
            }
            await bot.pathfinder.goto(new GoalNear(block.position.x, block.position.y+1, block.position.z, 0))
            setTimeout(drawLoop, 10000)
        }

            drawLoop()
            break

        case "equip":
            query = args[0] || null
            if (!query) {return}
            equipItem(query)
            // bot.chat(`/msg ${username} –ü—Ä–∏–≤–µ—Ç–∞!`);
            break
        case "slot":
            query = args[0] || null
            if (!query) {return}
            query = parseInt(query)
            bot.setQuickBarSlot(query)
            equipItem()
            // bot.chat(`/msg ${username} –ü—Ä–∏–≤–µ—Ç–∞!`);
            break
        case "speed":
            speed = args[0] || 1

            bot.on('physicsTick', () => {
                if (bot.pathfinder.isMoving()) {
                    bot.entity.velocity.x *= speed
                    bot.entity.velocity.z *= speed
                }
            })
            return;
        case "—Å–æ—Å–∞–ª?":
            if (args.length < 200) {
                bot.chat(`!–î–∞.`);
                return;
            }

            if (task) {
                bot.chat(`/msg ${username} –Ø —É–∂–µ –∑–∞–Ω—è—Ç –∑–∞–¥–∞–Ω–∏–µ–º ${task}`)
                bot.chat(`/msg ${WATCHED_PLAYERS[0]} –Ø —É–∂–µ –∑–∞–Ω—è—Ç –∑–∞–¥–∞–Ω–∏–µ–º ${task}`)
                return;
            }
        case "server":
            if (args.length < 200) {
                bot.chat("/server sleepcraft");
                return;
            }
        case "break":
            if (task) {
                bot.chat(`/msg ${WATCHED_PLAYERS[0]} –Ø —É–∂–µ –∑–∞–Ω—è—Ç –∑–∞–¥–∞–Ω–∏–µ–º ${task}`)
                bot.chat(`/msg ${username} –Ø —É–∂–µ –∑–∞–Ω—è—Ç –∑–∞–¥–∞–Ω–∏–µ–º ${task}`)
                return;
            }
            if (args.length < 2) {
                console.log('–£–∫–∞–∂–∏ –±–ª–æ–∫ –∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ: break <—Ç–∏–ø_–±–ª–æ–∫–∞> <–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ>')
                return;
            }
            const blockType = args[0];
            const amount = parseInt(args[1]);

            if (isNaN(amount) || amount <= 0) {
                return;
            }

            collectBlockType(blockType, amount);
            break;
        case "nearest":
            if (args.length < 1) {
                bot.chat(`/msg ${username} –£–∫–∞–∂–∏ —Ç–∏–ø —Å—É—â–Ω–æ—Å—Ç–∏: nearest <—Ç–∏–ø>`);
                bot.chat(`/msg ${WATCHED_PLAYERS[0]} –£–∫–∞–∂–∏ —Ç–∏–ø —Å—É—â–Ω–æ—Å—Ç–∏: nearest <—Ç–∏–ø>`);
                return;
            }
            let entityType = args[0];
            let nearestEntity = findEntityWithName(bot, entityType);

            if (nearestEntity) {
                const neName = nearestEntity.username || nearestEntity.displayName || nearestEntity.name || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è —Å—É—â–Ω–æ—Å—Ç—å';
                const nePos = nearestEntity.position.floored();
                const dist = bot.entity.position.distanceTo(nearestEntity.position).toFixed(1);
                bot.chat(`/msg ${WATCHED_PLAYERS[0]} –ë–ª–∏–∂–∞–π—à–∏–π ${entityType}: ${neName} –≤ [${nePos.x}, ${nePos.y}, ${nePos.z}] (${dist}–º)`);
                bot.chat(`/msg ${username} –ë–ª–∏–∂–∞–π—à–∏–π ${entityType}: ${neName} –≤ [${nePos.x}, ${nePos.y}, ${nePos.z}] (${dist}–º)`);
            } else {
                bot.chat(`/msg ${WATCHED_PLAYERS[0]} –ù–µ –Ω–∞–π–¥–µ–Ω–æ —Å—É—â–Ω–æ—Å—Ç–µ–π —Ç–∏–ø–∞ ${entityType} –ø–æ–±–ª–∏–∑–æ—Å—Ç–∏.`);
                bot.chat(`/msg ${username} –ù–µ –Ω–∞–π–¥–µ–Ω–æ —Å—É—â–Ω–æ—Å—Ç–µ–π —Ç–∏–ø–∞ ${entityType} –ø–æ–±–ª–∏–∑–æ—Å—Ç–∏.`);
            }
            break;
        case "come":
            if (task) {
                bot.chat(`/msg ${WATCHED_PLAYERS[0]} –Ø —É–∂–µ –∑–∞–Ω—è—Ç –∑–∞–¥–∞–Ω–∏–µ–º ${task}`)
                bot.chat(`/msg ${username} –Ø —É–∂–µ –∑–∞–Ω—è—Ç –∑–∞–¥–∞–Ω–∏–µ–º ${task}`)
                return;
            }

            let playerToCome;

            if (args.length < 1) {
                playerToCome = bot.players[username]?.entity;
                console.log('–ê—Ä–≥—É–º–µ–Ω—Ç–æ–≤ –Ω–µ—Ç')
            } else {
                let targetname = args[0];
                console.log('–ê—Ä–≥—É–º–µ–Ω—Ç—ã –µ—Å—Ç')
                playerToCome = findEntityWithName(bot, targetname);
            }



            if (playerToCome) {
                async function comePlayer() {
                    bot.pathfinder.setMovements(defaultMove);
                    console.log(`[DEBUG] –ü–µ—Ä–µ–¥ setGoal(GoalFollow): canDig=${bot.pathfinder.movements.canDig}, canPlaceBlocks=${bot.pathfinder.movements.canPlaceBlocks}, allow1by1towers=${bot.pathfinder.movements.allow1by1towers}`);
                    await bot.pathfinder.setGoal(new GoalFollow(playerToCome, 0));
                    task = null;
                    console.log("–ì–æ—Ç–æ–≤–æ!");
                }

                comePlayer();
            } else {
                bot.chat(`/m ${WATCHED_PLAYERS[0]} –Ø –Ω–µ –≤–∏–∂—É —Ü–µ–ª—å :(`)
                bot.chat(`/m ${WATCHED_PLAYERS[0]} –Ø —Ç–µ–±—è –Ω–µ –≤–∏–∂—É :(`)
            }
            break;
        case "teleport":
            if (task) {
                bot.chat(`/msg ${username} –ë—Ä–æ, —è –∑–∞–Ω—è—Ç –¥—Ä—É–≥–∏–º –∑–∞–¥–∞–Ω–∏–µ–º: ${task}`);
                return;
            }

            let playerToTeleport;

            if (args.length < 1) {
                playerToTeleport = bot.players[username]?.entity;
                console.log('[TP DEBUG] –¶–µ–ª—å ‚Äî –≤—ã–∑—ã–≤–∞—é—â–∏–π');
            } else {
                const targetTeleportName = args[0];
                playerToTeleport = findEntityWithName(bot, targetTeleportName);
                console.log('[TP DEBUG] –¶–µ–ª—å ‚Äî –ø–æ –∞—Ä–≥—É–º–µ–Ω—Ç—É');
            }

            if (!playerToTeleport) {
                bot.chat(`/msg ${username} –Ø –Ω–µ –≤–∏–∂—É —Ü–µ–ª—å –¥–ª—è —Ç–ø üò¢`);
                return;
            }

            const teleportTargetPosition = playerToTeleport.position;

            const enderPearlItem = bot.inventory.items().find(item => item.name === 'ender_pearl');
            if (!enderPearlItem) {
                bot.chat(`/msg ${username} –£ –º–µ–Ω—è –∑–∞–∫–æ–Ω—á–∏–ª–∏—Å—å –∂–µ–º—á—É–∂–∫–∏ üò≠`);
                return;
            }

        async function teleportToPlayer(targetPosition) {
            try {
                await bot.equip(enderPearlItem, 'hand');
                await bot.lookAt(targetPosition);

                bot.chat(`/msg ${username} –ü—Ä–∏—Ü–µ–ª–∏–ª—Å—è... –ö–∏–¥–∞—é!`);

                bot.activateItem();
                await bot.waitForTicks(5);
                bot.deactivateItem();

            } catch (teleportError) {
                console.log('[TP ERROR] –ù–µ —Å–º–æ–≥ ', teleportError);
                bot.chat(`/msg ${username} –ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫ —Å —Ç–µ–ª–µ–ø–æ—Ä—Ç–æ–º..`);
            }
        }

            teleportToPlayer(teleportTargetPosition);
            break;
        case "cometo":
            const player = bot.players[username]?.entity

            if (player) {
                const block = bot.blockAtEntityCursor(player, 100) // 6 ‚Äî –º–∞–∫—Å. –¥–∏—Å—Ç–∞–Ω—Ü–∏—è (–º–æ–∂–Ω–æ –±–æ–ª—å—à–µ)

                if (block) {
                    console.log(`—é–∑–µ—Ä —Å–º–æ—Ç—Ä–∏—Ç –Ω–∞ –±–ª–æ–∫: ${block.name} (${block.position})`)
                    async function comePos() {
                        bot.pathfinder.setMovements(defaultMove);
                        console.log(`[DEBUG] –ü–µ—Ä–µ–¥ setGoa: canDig=${bot.pathfinder.movements.canDig}, canPlaceBlocks=${bot.pathfinder.movements.canPlaceBlocks}, allow1by1towers=${bot.pathfinder.movements.allow1by1towers}`);
                        //await bot.pathfinder.(new GoalNear(vec3(, , ), 0));
                        await bot.pathfinder.goto(new GoalNear(Math.floor(block.position.x), Math.floor(block.position.y + 1), Math.floor(block.position.z), 2));
                        task = null;
                        console.log("–ì–æ—Ç–æ–≤–æ!");
                    }

                    comePos()

                } else {
                    console.log('–û–Ω —Å–º–æ—Ç—Ä–∏—Ç –≤ –ø—É—Å—Ç–æ—Ç—É –∏–ª–∏ —Å–ª–∏—à–∫–æ–º –¥–∞–ª–µ–∫–æ...')
                }
            } else {
                console.log('—é–∑–µ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –æ—Ñ—Ñ–ª–∞–π–Ω')
            }



            break;
        case "mode":
            if (!WATCHED_PLAYERS.includes(username)) {return}
            if (MODE === '–º–∏—Ä–Ω—ã–π') {
                MODE = '–∑–ª–æ–π'
            } else {
                MODE = '–º–∏—Ä–Ω—ã–π'
            }
            bot.chat(`/msg ${WATCHED_PLAYERS[0]} –ó–∞–¥–∞–Ω —Ä–µ–∂–∏–º '${MODE}'`)
            bot.chat(`/msg ${username} –ó–∞–¥–∞–Ω —Ä–µ–∂–∏–º '${MODE}'`)
            return
        case "stop":
            if (!WATCHED_PLAYERS.includes(username)) {
                sendFeedback(`${username} —Ö–æ—á–µ—Ç —á—Ç–æ–±—ã —è ${plainMessage}`)
                bot.chat(`/msg ${username} –Ø –Ω–µ –±—É–¥—É —ç—Ç–æ–≥–æ –¥–µ–ª–∞—Ç—å!!!`)
                return;
            }
            sendFeedback(`–û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—é—Å—å.`)
            bot.pvp.stop();
            followingProtectedPlayer = false;
            miningSand = false;
            following = false;
            bot.pathfinder.setGoal(null);
            bot.pathfinder.stop();
            bot.clearControlStates();
            collecting = false;
            task = null;
            break;
        case "stop-music":
            SOUND = null;
            playing = false;
            break;
        case "status":
            replyFeedback(username,`task: ${task}, sound: ${SOUND}, playing: ${playing}, statusses: ${readStates()}`)
            break;
        default:
            break;
    }
}

function getRussianName(itemId) {
    const item = mcData.itemsByName[itemId];
    return item ? item.displayName : `–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –ø—Ä–µ–¥–º–µ—Ç (${itemId})`;
}

let justSentLogin = false;

bot.on('resourcePack', (url, hash) => {
    // console.log('–°–µ—Ä–≤–µ—Ä –ø—Ä–µ–¥–ª–æ–∂–∏–ª –ø–∞–∫–µ—Ç —Ä–µ—Å—É—Ä—Å–æ–≤. –ü—Ä–∏–Ω–∏–º–∞—é.');
    bot.acceptResourcePack();
});

bot.on('spawn', () => {
    sendFeedback(`–ø–ª—é—Ö!`);
    // console.log("–°–æ–±—ã—Ç–∏–µ 'spawn' –ø–æ–ª—É—á–µ–Ω–æ.");
    initializeBotState();

});

bot.once('login', () => {
    // bot.chat(`/msg ${WATCHED_PLAYERS[0]} –ø–ª—é—Ö`);
    bot.chat(`/l ${PASSWORD}`);
    // console.log("–°–æ–±—ã—Ç–∏–µ 'spawn' –ø–æ–ª—É—á–µ–Ω–æ.");
    // initializeBotState();
    bot.chat('/server sleepcraft');

});

bot.on("plasmovoice_audio_end", () => {
    SOUND = null
})

bot.on('entitySpawn', (entity) => {
    if (entity.name !== 'item') {
        return
    }
    const { x, y, z } = entity.position
    const nearest = Object.values(bot.players)
        .map(p => p.entity)
        .filter(e => e && e.position.distanceTo(entity.position) <= 2.5)
        .sort((a, b) => a.position.distanceTo(entity.position) - b.position.distanceTo(entity.position))[0]
    if (!nearest) return

    setTimeout(() => {
        const meta = entity.metadata?.[8]
        const id = meta?.itemId
        const count = meta?.itemCount
        const name = getRussianName(itemProtocolIdMap?.[id]) || `id:${id}`
        let loreItem = '–Ω–µ—Ç';
        try {
            loreItem = entity.metadata[8].nbtData.value.display.value.Lore.value.value[0]
                .split('–ü–æ–¥–ø–∏—Å—å: #')[1]
                .split('","bold"')[0];
        } catch (e) {
        }
        maybe_latest_block = [new vec3(Math.round(x), Math.round(y), Math.round(z)), itemProtocolIdMap?.[id]]
        if (latestBrokenBlock !== maybe_latest_block) {
            console.log(maybe_latest_block)
            console.log(`${nearest.username} => ${name} x${count} –≤ ${Math.round(x)} ${Math.round(y)} ${Math.round(z)} –ø–æ–¥–ø–∏—Å—å ${loreItem}`)
        }
    }, 200)
})

bot.on('playerCollect', (player, item) => {
    id = item?.metadata?.[8]?.itemId
    count = item?.metadata?.[8]?.itemCount

    if (id) {
        name = getRussianName(itemProtocolIdMap[id])
    } else {
        name = item.name
    }



    const { x, y, z } = item.position
    const roundedX = Math.round(x)
    const roundedY = Math.round(y)
    const roundedZ = Math.round(z)

    let loreItem = '–Ω–µ—Ç';
    try {
        loreItem = item.metadata[8].nbtData.value.display.value.Lore.value.value[0]
            .split('–ü–æ–¥–ø–∏—Å—å: #')[1]
            .split('","bold"')[0];
    } catch (e) {
    }

    // if (WATCHED_PLAYERS.includes(loreItem)) {
    // if (loreItem) {
    //     bot.chat(`/msg ${WATCHED_PLAYERS[0]} ${player.username} <- ${name} x${count} –≤ ${roundedX} ${roundedY} ${roundedZ}, –ø–æ–¥–ø–∏—Å—å: ${loreItem}`)
    // } else {
    if (id) console.log(`${player.username} <= ${name} x${count} –≤ ${roundedX} ${roundedY} ${roundedZ} —Å –ø–æ–¥–ø–∏—Å—å—é ${loreItem}`)
    else console.log(`${player.username} <= ${name} –≤ ${roundedX} ${roundedY} ${roundedZ}`)
    // }
    // console.log(JSON.stringify(item?.metadata, null, 2));
    // console.log(require('util').inspect(item?.metadata, { depth: null, colors: true }));
})

bot.on('blockUpdate', (oldBlock, newBlock) => {
    if (!oldBlock || !newBlock || oldBlock.type === newBlock.type) {
        return
    }

    const { x, y, z } = oldBlock.position
    const nearestPlayer = Object.values(bot.players)
        .map(p => p.entity)
        .find(e => e && e.position.distanceTo(oldBlock.position) <= 2.5)

    if (!nearestPlayer) return

    const { username } = nearestPlayer
    const oldBlockName = oldBlock.name
    const newBlockName = newBlock.name

    if (!['air', 'water', 'lava'].includes(oldBlockName)) {
        console.log(`${username} [-] ${oldBlockName} –≤ ${Math.round(x)} ${Math.round(y)} ${Math.round(z)}.`)
        setLatestBrokenBlock(oldBlock)
    } else {
        console.log(`${username} [+] ${newBlockName} –≤ ${Math.round(x)} ${Math.round(y)} ${Math.round(z)}`)
    }

    })


rl.on('line', (line) => {
    const input = line.trim();
    if (input.length === 0) {
        rl.prompt();
        return;
    }

    const fakeUsername = 'console';
    processCommand(input, fakeUsername, input);
    rl.prompt();
});

bot.on('message', (jsonMsg, position) => {
    console.log(jsonMsg.toAnsi());
    let plainMessage = jsonMsg.toString();

    if (plainMessage === "Your login session has been continued." || plainMessage === "Your connection to sleepcraft encountered a problem." || plainMessage === "You have successfully logged.") {
        connectToServer()
    }

    if (plainMessage.includes(' ‚Ä∫ ') || plainMessage.startsWith('üí¨ [–î–°] ')) {
        if (plainMessage.includes('–í–∞–º] ‚Ä∫ ')) {
            // [vlkardakov -> –í–∞–º] ‚Ä∫ come
            message = plainMessage.split('–í–∞–º] ‚Ä∫ ')[1]
            username = plainMessage.split('[')[1].split(' ->')[0]

        } else if (plainMessage.startsWith('üí¨ [–î–°] ')) {
            // üí¨ [–î–°] vlkardakov: —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–∑ –¥–∏—Å–∫–æ—Ä–¥–∞
            plainMessage = plainMessage.replace('üí¨ [–î–°] ', '')
            // vlkardakov: —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–∑ –¥–∏—Å–∫–æ—Ä–¥–∞
            message = plainMessage.split(': ')[1]
            // —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–∑ –¥–∏—Å–∫–æ—Ä–¥–∞
            username = plainMessage.split(': ')[0]
            // vlkardakov

        } else if (plainMessage.includes(' ‚Ä∫ ')) {
            // vlkardakov ‚Ä∫ come
            message = plainMessage.split(' ‚Ä∫ ')[1]
            username = plainMessage.split(' ‚Ä∫ ')[0]

        }

        // console.log(`username: '${username}', command: '${command}'`);
        processCommand(message, username, plainMessage)
    }
});

bot.on('kicked', (reason, loggedIn) => {
    console.error('–ë–æ—Ç –±—ã–ª –∫–∏–∫–Ω—É—Ç!');
    console.error('--- –î–µ—Ç–∞–ª–∏ –ü—Ä–∏—á–∏–Ω—ã –ö–∏–∫–∞ ---');
    try {
        console.error(JSON.stringify(reason, null, 2));
    } catch (e) {
        console.error(reason);
    }
    console.error('-------------------------');
    isInitialSpawn = true;
});

bot.on('error', (err) => {
    console.error('–û—à–∏–±–∫–∞ –±–æ—Ç–∞:', err);
});

bot.on('end', (reason) => {
    console.log(`–ë–æ—Ç –æ—Ç–∫–ª—é—á–∏–ª—Å—è. –ü—Ä–∏—á–∏–Ω–∞: ${reason}`);
    isInitialSpawn = true;
});

process.on('unhandledRejection', (reason, promise) => {
    console.error('Unhandled Rejection at:', promise, 'reason:', reason);
});

process.on('uncaughtException', (err) => {
    console.error('–ù–µ–ø–µ—Ä–µ—Ö–≤–∞—á–µ–Ω–Ω–æ–µ –∏—Å–∫–ª—é—á–µ–Ω–∏–µ:', err);
});