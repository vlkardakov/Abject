"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class ByteArrayDataOutput {
    buffer;
    view;
    offset;
    constructor(initialCapacity = 32) {
        this.buffer = new ArrayBuffer(initialCapacity);
        this.view = new DataView(this.buffer);
        this.offset = 0;
    }
    ensureCapacity(additionalCapacity) {
        const requiredCapacity = this.offset + additionalCapacity;
        if (requiredCapacity > this.buffer.byteLength) {
            const newCapacity = Math.max(this.buffer.byteLength * 2, requiredCapacity);
            const newBuffer = new ArrayBuffer(newCapacity);
            new Uint8Array(newBuffer).set(new Uint8Array(this.buffer));
            this.buffer = newBuffer;
            this.view = new DataView(this.buffer);
        }
    }
    writeBoolean(value) {
        this.ensureCapacity(1);
        this.view.setUint8(this.offset, value ? 1 : 0);
        this.offset += 1;
    }
    writeByte(value) {
        this.ensureCapacity(1);
        this.view.setInt8(this.offset, value);
        this.offset += 1;
    }
    writeUnsignedByte(value) {
        this.ensureCapacity(1);
        this.view.setUint8(this.offset, value);
        this.offset += 1;
    }
    writeShort(value) {
        this.ensureCapacity(2);
        this.view.setInt16(this.offset, value, false); // Big-endian
        this.offset += 2;
    }
    writeUnsignedShort(value) {
        this.ensureCapacity(2);
        this.view.setUint16(this.offset, value, false); // Big-endian
        this.offset += 2;
    }
    writeInt(value) {
        this.ensureCapacity(4);
        this.view.setInt32(this.offset, value, false); // Big-endian
        this.offset += 4;
    }
    writeLong(value) {
        this.ensureCapacity(8);
        this.view.setBigInt64(this.offset, value, false); // Big-endian
        this.offset += 8;
    }
    writeFloat(value) {
        this.ensureCapacity(4);
        this.view.setFloat32(this.offset, value, false); // Big-endian
        this.offset += 4;
    }
    writeDouble(value) {
        this.ensureCapacity(8);
        this.view.setFloat64(this.offset, value, false); // Big-endian
        this.offset += 8;
    }
    writeBytes(bytes) {
        this.ensureCapacity(bytes.length);
        new Uint8Array(this.buffer, this.offset, bytes.length).set(bytes);
        this.offset += bytes.length;
    }
    writeUTF(value) {
        const encoder = new TextEncoder();
        const encoded = encoder.encode(value);
        this.writeUnsignedShort(encoded.length); // Write the length as an unsigned short
        this.writeBytes(encoded);
    }
    getBytes() {
        return new Uint8Array(this.buffer, 0, this.offset);
    }
}
exports.default = ByteArrayDataOutput;
