"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Utils_1 = __importDefault(require("./Utils"));
const lib_1 = require("./lib");
const PacketClientHandler_1 = __importDefault(require("./packet/PacketClientHandler"));
const PacketSocketHandler_1 = __importDefault(require("./packet/PacketSocketHandler"));
const StoredData_1 = __importDefault(require("./packet/StoredData"));
class Core {
    bot;
    packetClientHandler;
    packetSocketHandler;
    storedData;
    lastPlayerAudioPacketTimestamp = 0;
    stopFlag = false;
    constructor(bot) {
        this.bot = bot;
        this.packetClientHandler = new PacketClientHandler_1.default(this);
        this.packetSocketHandler = new PacketSocketHandler_1.default(this);
        this.storedData = new StoredData_1.default();
        process.on("SIGINT", () => {
            if (this.packetSocketHandler.socket?.address()) {
                this.packetSocketHandler.socket.close();
                delete this.packetSocketHandler.socket;
            }
            process.exit(0);
        });
    }
    isTalking() {
        return Date.now() - this.lastPlayerAudioPacketTimestamp < 15 * 1.5;
    }
    async stopTalking() {
        if (!this.isTalking()) {
            return;
        }
        this.stopFlag = true;
        return await new Promise((resolve) => this.bot.once("plasmovoice_audio_end", () => {
            this.stopFlag = false;
            resolve(undefined);
        }));
    }
    async sendPCM(pcmBuffer, distance, activation) {
        this.stopFlag = false;
        if (this.isTalking()) {
            lib_1.log.error(new Error("Voice channel is busy"));
            return;
        }
        const frameSize = (this.storedData.config.captureInfo.sampleRate / 1_000) * 40;
        const activationUUID = Utils_1.default.getActivationUUID(activation);
        // Cut pcm to frames
        const frames = [];
        for (let i = 0; i < pcmBuffer.length; i += frameSize) {
            const frame = pcmBuffer.subarray(i, i + frameSize);
            frames.push(frame);
        }
        for (let i = 0; i < frames.length; i++) {
            // Stopping method
            if (this.stopFlag) {
                lib_1.log.info("Voice interrupted");
                break;
            }
            const frame = frames[i];
            // Last frame (by default is empty or silent)
            if (frame.length !== frameSize) {
                break;
            }
            const opus = this.packetSocketHandler.packetEncoder.encodePCM(frame);
            const ecryptedOpus = this.packetSocketHandler.packetEncoder.encryptOpus(opus);
            this.packetSocketHandler.playerAudioPacket.send({
                sequenceNumber: BigInt(i),
                data: ecryptedOpus,
                activationId: activationUUID,
                distance: distance,
                stereo: false,
            });
            this.lastPlayerAudioPacketTimestamp = Date.now();
            await new Promise((r) => setTimeout(r, 10));
        }
        this.bot.emit("plasmovoice_audio_end");
    }
}
exports.default = Core;
