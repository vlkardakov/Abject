"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const opus_1 = require("@discordjs/opus");
const crypto_1 = __importDefault(require("crypto"));
const node_rsa_1 = __importDefault(require("node-rsa"));
class PacketSocketEncoder {
    core;
    aesKey;
    opusEncoder;
    rsaDecoder;
    constructor(core) {
        this.core = core;
    }
    prepare() {
        if (!this.core.storedData.config)
            throw new Error("Config is not received");
        this.rsaDecoder = new node_rsa_1.default(this.core.storedData.keyPair.privateKey, "private", {
            encryptionScheme: "pkcs1",
        });
        // By default it will use the node crypto library with the CVE
        this.rsaDecoder.setOptions({ environment: "browser" });
        this.aesKey = this.rsaDecoder.decrypt(Buffer.from(this.core.storedData.config.encryptionInfo.data));
        this.opusEncoder = new opus_1.OpusEncoder(this.core.storedData.config.captureInfo.sampleRate, 1);
    }
    encodePCM(buffer) {
        if (!this.opusEncoder)
            throw new Error("Not initialized");
        return this.opusEncoder.encode(buffer);
    }
    decodePCM(buffer) {
        if (!this.opusEncoder)
            throw new Error("Not initialized");
        return this.opusEncoder.decode(buffer);
    }
    encryptOpus(data) {
        if (!this.aesKey)
            throw new Error("Not initialized");
        const iv = crypto_1.default.randomBytes(16);
        const cipher = crypto_1.default.createCipheriv("aes-128-cbc", this.aesKey, iv);
        const encrypted = Buffer.concat([cipher.update(data), cipher.final()]);
        return Buffer.concat([iv, encrypted]);
    }
    decryptOpus(data) {
        if (!this.aesKey)
            throw new Error("Not initialized");
        const iv = data.subarray(0, 16);
        const encrypted = data.subarray(16);
        const decipher = crypto_1.default.createDecipheriv("aes-128-cbc", this.aesKey, iv);
        const decrypted = Buffer.concat([
            decipher.update(encrypted),
            decipher.final(),
        ]);
        return decrypted;
    }
}
exports.default = PacketSocketEncoder;
