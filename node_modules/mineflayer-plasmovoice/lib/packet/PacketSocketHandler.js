"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const dgram_1 = __importDefault(require("dgram"));
const Utils_1 = __importDefault(require("../Utils"));
const lib_1 = require("../lib");
const PacketSocketEncoder_1 = __importDefault(require("./PacketSocketEncoder"));
const PingPacket_1 = __importDefault(require("./socket/PingPacket"));
const PlayerAudioPacket_1 = __importDefault(require("./socket/PlayerAudioPacket"));
const SourceAudioPacket_1 = __importDefault(require("./socket/SourceAudioPacket"));
class PacketSocketHandler {
    core;
    packetEncoder;
    pingPacket;
    playerAudioPacket;
    sourceAudioPacket;
    ip;
    port;
    secret;
    socket;
    constructor(core) {
        this.core = core;
        lib_1.log.debug("Registering socket packet encoder");
        this.packetEncoder = new PacketSocketEncoder_1.default(this.core);
    }
    connect(ip, port, secret) {
        this.ip =
            ip == "0.0.0.0"
                ? (this.core.bot._client.socket._host ??
                    this.core.bot._client.socket.remoteAddress)
                : ip;
        this.port = port ?? this.core.bot._client.socket.remotePort ?? 25565;
        this.secret = secret;
        this.socket = dgram_1.default.createSocket("udp4");
        this.socket.on("connect", () => {
            lib_1.log.getSubLogger({ name: "Socket" }).debug("Connected to the socket");
            this.setupPackets();
            const connector = setInterval(() => {
                if (this.core.storedData.config === undefined) {
                    this.pingPacket.send({
                        currentTime: BigInt(Date.now()),
                        serverIp: this.ip,
                        serverPort: this.port,
                    });
                }
                else {
                    clearInterval(connector);
                }
            }, 500);
        });
        this.socket.on("close", () => {
            lib_1.log.warn(`Socket closed`);
        });
        this.socket.on("error", (err) => {
            lib_1.log.fatal(`Socket error: ${err.message}`);
        });
        this.socket.connect(this.port, this.ip);
    }
    setupPackets() {
        if (!this.socket)
            throw new Error("Socket is not up");
        this.pingPacket = new PingPacket_1.default(this.core);
        this.playerAudioPacket = new PlayerAudioPacket_1.default(this.core);
        this.sourceAudioPacket = new SourceAudioPacket_1.default(this.core);
        this.pingPacket.on("packet", () => {
            this.pingPacket.send({
                currentTime: BigInt(Date.now()),
            });
        });
        this.sourceAudioPacket.on("packet", (data) => {
            if (this.core.storedData.sourceById.some((item) => Utils_1.default.objectEquals(item.sourceId, data.sourceId))) {
                // Sound event
                const sourceData = this.core.storedData.sourceById.find((item) => Utils_1.default.objectEquals(item.sourceId, data.sourceId));
                if (!sourceData) {
                    return;
                }
                this.core.bot.emit("plasmovoice_voice", {
                    player: sourceData.playerName,
                    distance: data.distance,
                    sequenceNumber: data.sequenceNumber,
                    data: this.packetEncoder.decodePCM(this.packetEncoder.decryptOpus(data.data)),
                });
            }
            else {
                // Requesting source info
                this.core.packetClientHandler.sourceInfoRequestPacket.send({
                    sourceId: data.sourceId,
                });
            }
            return;
        });
    }
}
exports.default = PacketSocketHandler;
