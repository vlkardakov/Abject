"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Utils_1 = __importDefault(require("../Utils"));
const lib_1 = require("../lib");
const PacketClientEncoder_1 = __importDefault(require("./PacketClientEncoder"));
const ConfigPacket_1 = __importDefault(require("./client/ConfigPacket"));
const ConnectionPacket_1 = __importDefault(require("./client/ConnectionPacket"));
const PlayerInfoPacket_1 = __importDefault(require("./client/PlayerInfoPacket"));
const PlayerInfoRequestPacket_1 = __importDefault(require("./client/PlayerInfoRequestPacket"));
const PlayerStatePacket_1 = __importDefault(require("./client/PlayerStatePacket"));
const SourceAudioEndPacket_1 = __importDefault(require("./client/SourceAudioEndPacket"));
const SourceInfoPacket_1 = __importDefault(require("./client/SourceInfoPacket"));
const SourceInfoRequestPacket_1 = __importDefault(require("./client/SourceInfoRequestPacket"));
class PacketClientHandler {
    core;
    packetEncoder;
    // Packets
    playerInfoRequestPacket;
    playerInfoPacket;
    connectionPacket;
    configPacket;
    sourceInfoPacket;
    sourceAudioEndPacket;
    playerStatePacket;
    sourceInfoRequestPacket;
    constructor(core) {
        this.core = core;
        lib_1.log.debug("Registering client packet encoder");
        this.packetEncoder = new PacketClientEncoder_1.default(this.core);
        lib_1.log.debug("Registering client packets");
        this.playerInfoRequestPacket = new PlayerInfoRequestPacket_1.default(this.core.bot);
        this.playerInfoPacket = new PlayerInfoPacket_1.default(this.core.bot);
        this.connectionPacket = new ConnectionPacket_1.default(this.core.bot);
        this.configPacket = new ConfigPacket_1.default(this.core.bot);
        this.sourceInfoPacket = new SourceInfoPacket_1.default(this.core.bot);
        this.sourceAudioEndPacket = new SourceAudioEndPacket_1.default(this.core.bot);
        this.playerStatePacket = new PlayerStatePacket_1.default(this.core.bot);
        this.sourceInfoRequestPacket = new SourceInfoRequestPacket_1.default(this.core.bot);
        this.playerInfoRequestPacket.on("packet", (data) => {
            this.playerInfoPacket.send({
                voiceDisabled: false,
                microphoneMuted: false,
                minecraftVersion: this.core.bot.version,
                version: "2.0.0",
                publicKey: this.core.storedData.keyPair.publicKey,
            });
        });
        this.connectionPacket.on("packet", (data) => {
            this.core.packetSocketHandler.connect(data.ip, data.port, data.secret);
        });
        this.configPacket.on("packet", (data) => {
            this.core.storedData.config = data;
            // Checking for supported encryption
            if (this.core.storedData.config.hasEncryptionInfo == false) {
                // FEAT: Support disabled encryption
                lib_1.log.fatal(new Error(`Encryption is disabled`));
                return;
            }
            if (this.core.storedData.config.encryptionInfo.algorithm !=
                "AES/CBC/PKCS5Padding") {
                lib_1.log.fatal(new Error(`Unsupported encryption type "${this.core.storedData.config.encryptionInfo.algorithm}"`));
                return;
            }
            this.core.packetSocketHandler.packetEncoder.prepare();
            this.core.bot.emit("plasmovoice_connected");
        });
        this.sourceInfoPacket.on("packet", (data) => {
            // Don't save a player, if it's exists
            if (this.core.storedData.sourceById.some((item) => item.playerName == data.playerInfo.playerNick))
                return;
            // Save player
            this.core.storedData.sourceById.push({
                sourceId: data.id,
                playerName: data.playerInfo.playerNick,
            });
        });
        this.sourceAudioEndPacket.on("packet", (data) => {
            const sourceData = this.core.storedData.sourceById.find((item) => Utils_1.default.objectEquals(item.sourceId, data.sourceId));
            if (!sourceData) {
                lib_1.log.warn(`Unknown sourceId in SourceAudioEndPacket: ${data.sourceId}, ignoring`);
                return;
            }
            this.core.bot.emit("plasmovoice_voice_end", {
                player: sourceData.playerName,
                sequenceNumber: data.sequenceNumber,
            });
        });
    }
}
exports.default = PacketClientHandler;
