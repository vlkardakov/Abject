"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SmoothLook = void 0;
const lookUtil_1 = require("./lookUtil");
const tween_js_1 = __importDefault(require("@tweenjs/tween.js"));
class SmoothLook {
    constructor(bot, debug = false) {
        this.bot = bot;
        this.debug = debug;
        this.goodEnoughDot = 0.9999;
        this._beginTween = (tween) => {
            tween.start(tween_js_1.default.now() - 50);
            tween.update();
        };
        this.currentlyLooking = false;
        this.easing = tween_js_1.default.Easing.Elastic.Out;
        this._task = null;
        this._pendingTask = null;
    }
    setEasing(func) {
        this.easing = func;
    }
    /**
     * Wraps the euler so the walk from start to finish is clean,
     * no snapback when neg to pos values.
     */
    _wrapRotationEuler(start, dest) {
        const startYaw = start.x;
        let destYaw = dest.x;
        const deltaYaw = destYaw - startYaw;
        // console.log('wrap', startYaw, destYaw, deltaYaw)
        if (deltaYaw > Math.PI) {
            destYaw -= 2 * Math.PI;
        }
        else if (deltaYaw < -Math.PI) {
            destYaw += 2 * Math.PI;
        }
        dest.x = destYaw;
        return dest;
    }
    /**
     * Build custom Tween that interacts w/ the bot object
     * and cleans itself up once finishing.
     */
    _buildTask(start, dest, closeEnoughDot = this.goodEnoughDot) {
        const duration = this.estimateTurnTime(dest.x, dest.y);
        return new tween_js_1.default.Tween(start)
            .to(dest, duration)
            .easing(this.easing)
            .onUpdate((current, elapsed) => {
            var _a;
            this.bot.look(current.x, current.y, true);
            const curVec3 = (0, lookUtil_1.yawPitchToDir)(current.x, current.y);
            const destVec3 = (0, lookUtil_1.yawPitchToDir)(dest.x, dest.y);
            const dot = curVec3.dot(destVec3);
            if (dot > closeEnoughDot) {
                if (this._pendingTask) {
                    this._launchNextTaskFromCancel(this._pendingTask.dest, this._pendingTask.closeEnoughDot);
                }
                else {
                    (_a = this._task) === null || _a === void 0 ? void 0 : _a.stop();
                }
            }
        })
            .onComplete((current) => {
            if (this._task && this._task._chainedTweens.length === 0) {
                this._task = null;
            }
        });
    }
    /**
     * Unused. Would clean up internal tasks.
     */
    _cleanupTasks(chained = true) {
        if (this._task) {
            this._task.stop();
            if (chained)
                this._task.stopChainedTweens();
            this._task = null;
        }
    }
    /**
     * Used by force value. Cancel current task,
     * then start on current tween value to wanted destination.
     * This smoothly connects tweens (standard chaining is broken).
     */
    _launchNextTaskFromCancel(dest, closeEnoughDot = this.goodEnoughDot) {
        if (this._task) {
            this._task
                .onStop((current) => {
                this._task = this._buildTask(current, this._wrapRotationEuler(current, dest), closeEnoughDot);
                this._beginTween(this._task);
                if (this._pendingTask) {
                    this._pendingTask = null;
                }
            })
                .stop();
        }
    }
    /**
     * Used by non-force. Wait for current task to end,
     * then begin new task from current position.
     * This does not cancel the current task and overrides the initial custom task clear.
     */
    eventuallyChain(dest, closeEnoughDot = this.goodEnoughDot) {
        if (this._task) {
            this._task.onComplete((current) => {
                this._pendingTask = null;
                this._task = this._buildTask(current, this._wrapRotationEuler(current, dest), closeEnoughDot);
                this._beginTween(this._task);
            });
            this._pendingTask = { dest, closeEnoughDot };
        }
    }
    /**
     * Estimate the time it takes to turn to a certain yaw/pitch.
     * This is used to determine the duration of the tween.
     *
     * @param yaw
     * @param pitch
     * @returns estimated time in ms
     */
    estimateTurnTime(yaw, pitch) {
        const curYaw = this.bot.entity.yaw;
        const curPitch = this.bot.entity.pitch;
        const yawDiff = Math.abs(curYaw - yaw);
        const pitchDiff = Math.abs(curPitch - pitch);
        // 50ms * bot's yaw/pitch diff
        const maxDeltaYaw = 0.05 * this.bot.physics.yawSpeed;
        const maxDeltaPitch = 0.05 * this.bot.physics.pitchSpeed;
        const yawTicks = yawDiff / maxDeltaYaw;
        const pitchTicks = pitchDiff / maxDeltaPitch;
        return Math.max(yawTicks, pitchTicks) * 20;
    }
    look(yaw, pitch, force = true, closeEnoughDot = this.goodEnoughDot) {
        return __awaiter(this, void 0, void 0, function* () {
            this.lookTowards((0, lookUtil_1.yawPitchToDir)(yaw, pitch), force, closeEnoughDot);
        });
    }
    lookTowards(dir, force = true, closeEnoughDot = this.goodEnoughDot) {
        const startRotation = (0, lookUtil_1.lookingAtEuler)(this.bot.entity.yaw, this.bot.entity.pitch);
        const endRotation = (0, lookUtil_1.dirToEuler)(dir);
        return this._lookHandler(startRotation, endRotation, force, closeEnoughDot);
    }
    lookAt(target, force = true, closeEnoughDot = this.goodEnoughDot) {
        const startRotation = (0, lookUtil_1.lookingAtEuler)(this.bot.entity.yaw, this.bot.entity.pitch);
        const endRotation = (0, lookUtil_1.targetEuler)(this.bot.entity.position.offset(0, this.bot.entity.eyeHeight, 0), target);
        return this._lookHandler(startRotation, endRotation, force, closeEnoughDot);
    }
    _lookHandler(startRotation, endRotation, force = true, closeEnoughDot = this.goodEnoughDot) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            this._wrapRotationEuler(startRotation, endRotation);
            if (((_a = this._task) === null || _a === void 0 ? void 0 : _a.isPlaying()) && !force) {
                this._debug("task running + not forcing.", tween_js_1.default.getAll().length, "tasks.");
                this.eventuallyChain(endRotation, closeEnoughDot);
            }
            else if (((_b = this._task) === null || _b === void 0 ? void 0 : _b.isPlaying()) && force) {
                this._debug("task running + forcing.", tween_js_1.default.getAll().length, "tasks.");
                this._launchNextTaskFromCancel(endRotation, closeEnoughDot);
            }
            else if (!((_c = this._task) === null || _c === void 0 ? void 0 : _c.isPlaying())) {
                this._debug("task not running, making new.", tween_js_1.default.getAll().length, "tasks.");
                this._task = this._buildTask(startRotation, endRotation, closeEnoughDot);
                this._beginTween(this._task);
            }
            yield new Promise((resolve) => {
                var _a;
                (_a = this._task) === null || _a === void 0 ? void 0 : _a.onComplete(() => {
                    resolve();
                }).onStop(() => {
                    resolve();
                });
            });
        });
    }
    _debug(message, ...optionalParams) {
        if (this.debug)
            console.log(message, ...optionalParams);
    }
}
exports.SmoothLook = SmoothLook;
