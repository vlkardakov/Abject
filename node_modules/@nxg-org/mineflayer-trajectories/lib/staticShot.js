"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StaticShot = void 0;
const constants_1 = require("./calc/constants");
const mineflayer_util_plugin_1 = require("@nxg-org/mineflayer-util-plugin");
const { getEntityAABBRaw } = mineflayer_util_plugin_1.AABBUtils;
class StaticShot {
    static checkForEntityHitFromSortedPoints({ position, height, width }, points, notchianPointVecs, blockChecker, blockChecking = false) {
        var _a;
        if (points.length === 0 || notchianPointVecs.length === 0)
            throw "Not enough points.";
        if (points.length !== notchianPointVecs.length)
            throw "Invalid positions or velocities: Different amount of inputs.";
        const entityAABB = getEntityAABBRaw({ position, height, width });
        let nearestDistance = entityAABB.distanceToVec(points[0]);
        let currentDistance;
        let closestPoint = points[0];
        let intersect = null;
        let block = null;
        for (let i = 0; i < points.length; i++) {
            const point = points[i];
            currentDistance = entityAABB.distanceToVec(point);
            if (nearestDistance > currentDistance)
                break;
            nearestDistance = currentDistance;
            closestPoint = point;
            const nextPoint = point.clone().add(notchianPointVecs[i]);
            if (blockChecking && blockChecker) {
                block = (_a = blockChecker.check(point, nextPoint)) === null || _a === void 0 ? void 0 : _a.block;
                if (block)
                    break;
            }
            intersect = entityAABB.intersectsSegment(point, nextPoint);
            if (intersect)
                break;
        }
        return { closestPoint: intersect !== null && intersect !== void 0 ? intersect : closestPoint, blockHit: block };
    }
    static calculateShotForCollision({ position, velocity, name }, target, blockChecking = false, blockChecker) {
        var _a;
        if (!constants_1.projectileGravity[name])
            throw "invalid projectile: " + name;
        const gravity = constants_1.projectileGravity[name];
        const entityAABB = getEntityAABBRaw(target);
        let points = [];
        let pointVelocities = [];
        let blockHit = null;
        let intersectPos = null;
        let tickVelocity = velocity.clone();
        let currentPosition = position.clone();
        let nextPosition = position.clone().add(tickVelocity);
        let totalTicks = 0;
        let aH = constants_1.projectileAirResistance[name];
        let aY = constants_1.projectileAirResistance[name];
        let offsetX = -tickVelocity.x * aH;
        let offsetY = -tickVelocity.y * aY - gravity;
        let offsetZ = -tickVelocity.z * aH;
        while (totalTicks < 300) {
            points.push(currentPosition.clone());
            pointVelocities.push(tickVelocity.clone());
            offsetX = -tickVelocity.x * aH;
            offsetY = -tickVelocity.y * aY - gravity;
            offsetZ = -tickVelocity.z * aH;
            if (blockChecking && blockChecker) {
                blockHit = (_a = blockChecker.check(currentPosition, nextPosition)) === null || _a === void 0 ? void 0 : _a.block;
                if (blockHit)
                    break;
            }
            intersectPos = entityAABB.intersectsSegment(currentPosition, nextPosition);
            if (intersectPos)
                break;
            if (tickVelocity.y < 0 && currentPosition.y < 0)
                break;
            currentPosition.add(tickVelocity);
            tickVelocity.translate(offsetX, offsetY, offsetZ);
            nextPosition.add(tickVelocity);
        }
        return { positions: points, velocities: pointVelocities, blockHit, intersectPos };
    }
    static calculateShotForPoints({ position, velocity, name }, blockChecking = false, blockChecker) {
        var _a;
        if (!constants_1.projectileGravity[name])
            throw "invalid projectile: " + name;
        const gravity = constants_1.projectileGravity[name];
        let points = [];
        let pointVelocities = [];
        let blockHit = null;
        let currentVelocity = velocity.clone();
        let currentPosition = position.clone();
        let nextPosition = position.clone().add(currentVelocity);
        let totalTicks = 0;
        let aH = constants_1.projectileAirResistance[name];
        let aY = constants_1.projectileAirResistance[name];
        let offsetX = -currentVelocity.x * aH;
        let offsetY = -currentVelocity.y * aY - gravity;
        let offsetZ = -currentVelocity.z * aH;
        while (totalTicks < 300) {
            points.push(currentPosition.clone());
            pointVelocities.push(currentVelocity.clone());
            offsetX = -currentVelocity.x * aH;
            offsetY = -currentVelocity.y * aY - gravity;
            offsetZ = -currentVelocity.z * aH;
            if (blockChecking && blockChecker) {
                blockHit = (_a = blockChecker.check(currentPosition, nextPosition)) === null || _a === void 0 ? void 0 : _a.block;
                if (blockHit) {
                    // TODO: add block hit position
                    break;
                }
            }
            if (currentVelocity.y < 0 && currentPosition.y < 0)
                break;
            currentPosition.add(currentVelocity);
            currentVelocity.translate(offsetX, offsetY, offsetZ);
            nextPosition.add(currentVelocity);
        }
        return { positions: points, velocities: pointVelocities, blockHit };
    }
}
exports.StaticShot = StaticShot;
